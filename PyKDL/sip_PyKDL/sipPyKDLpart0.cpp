/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 13 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 19 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 23 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 27 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 33 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 27 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 36 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 42 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 48 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 102 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 54 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 358 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 58 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 62 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 66 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 100 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 70 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 207 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 74 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 78 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 111 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 83 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 150 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 88 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 186 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 93 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 208 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 98 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 102 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 258 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 106 "sip_PyKDL/sipPyKDLpart0.cpp"

/* Define the strings used by this module. */
const char sipStrings_PyKDL[] = {
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'g', 'i', 'v', 'e', 'n', 's', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'D', 'a', 't', 'a', 'S', 't', 'r', 'u', 'c', 't', 'u', 'r', 'e', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'n', 's', 'o', 0,
    'C', 'h', 'a', 'i', 'n', 'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'D', 'o', 't', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', '_', 'J', 'L', 0,
    'J', 'n', 't', 'S', 'p', 'a', 'c', 'e', 'I', 'n', 'e', 'r', 't', 'i', 'a', 'M', 'a', 't', 'r', 'i', 'x', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'w', 'd', 'l', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'L', 'M', 'A', 0,
    'g', 'e', 't', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'W', 'r', 'e', 'n', 'c', 'h', '>', 0,
    'C', 'h', 'a', 'i', 'n', 'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'd', 'S', 'o', 'l', 'v', 'e', 'r', '_', 'R', 'N', 'E', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 'J', 'a', 'c', 'o', 'b', 'i', 'a', 'n', 0,
    'R', 'i', 'g', 'i', 'd', 'B', 'o', 'd', 'y', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'J', 'o', 'i', 'n', 't', ':', ':', 'J', 'o', 'i', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'S', 'e', 'g', 'm', 'e', 'n', 't', 's', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'F', 'r', 'a', 'm', 'e', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'P', 'o', 'i', 'n', 't', 0,
    'n', 'e', 'w', 'N', 'r', 'O', 'f', 'C', 'o', 'l', 'u', 'm', 'n', 's', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'o', 'r', 'i', 'o', 'l', 'i', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'D', 'y', 'n', 'P', 'a', 'r', 'a', 'm', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'd', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'J', 'o', 'i', 'n', 't', 's', 0,
    'g', 'e', 't', 'F', 'r', 'a', 'm', 'e', 'T', 'o', 'T', 'i', 'p', 0,
    'G', 'e', 't', 'Q', 'u', 'a', 't', 'e', 'r', 'n', 'i', 'o', 'n', 0,
    'J', 'n', 't', 'T', 'o', 'G', 'r', 'a', 'v', 'i', 't', 'y', 0,
    'D', 'H', '_', 'C', 'r', 'a', 'i', 'g', '1', '9', '8', '9', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 'D', 'o', 't', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'V', 'e', 'l', 0,
    'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'D', 'o', 't', 0,
    '_', 'e', 'p', 's', '_', 'j', 'o', 'i', 'n', 't', 's', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'J', 'S', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'T', 'S', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 'V', 'e', 'l', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 'N', 'a', 'm', 'e', 0,
    'J', 'o', 'i', 'n', 't', 'O', 'r', 'i', 'g', 'i', 'n', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'X', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'Z', 0,
    'G', 'e', 't', 'R', 'o', 't', 'A', 'n', 'g', 'l', 'e', 0,
    'R', 'e', 'v', 'e', 'r', 's', 'e', 'S', 'i', 'g', 'n', 0,
    '_', '_', 's', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    '_', '_', 'g', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    's', 't', 'd', ':', ':', 's', 't', 'r', 'i', 'n', 'g', 0,
    'g', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 's', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 's', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'B', 'a', 's', 'e', 0,
    'c', 'h', 'a', 'i', 'n', '_', 'r', 'o', 'o', 't', 0,
    'g', 'e', 't', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    'a', 'd', 'd', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    's', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'g', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'S', 'e', 't', 'I', 'n', 'v', 'e', 'r', 's', 'e', 0,
    'J', 'n', 't', 'T', 'o', 'M', 'a', 's', 's', 0,
    'V', 'e', 'c', 't', 'o', 'r', 'V', 'e', 'l', 0,
    'd', 'o', 'u', 'b', 'l', 'e', 'V', 'e', 'l', 0,
    'g', 'e', 't', 'O', 'p', 't', 'P', 'o', 's', 0,
    's', 'e', 't', 'O', 'p', 't', 'P', 'o', 's', 0,
    's', 'e', 't', 'L', 'a', 'm', 'b', 'd', 'a', 0,
    'C', 'a', 'r', 't', 'T', 'o', 'J', 'n', 't', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'a', 'r', 't', 0,
    's', 'e', 'g', 'm', 'e', 'n', 't', 'N', 'r', 0,
    's', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'g', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'c', 'h', 'a', 'i', 'n', '_', 't', 'i', 'p', 0,
    'h', 'o', 'o', 'k', '_', 'n', 'a', 'm', 'e', 0,
    'r', 'o', 'o', 't', '_', 'n', 'a', 'm', 'e', 0,
    'J', 'o', 'i', 'n', 't', 'A', 'x', 'i', 's', 0,
    's', 't', 'i', 'f', 'f', 'n', 'e', 's', 's', 0,
    'T', 'r', 'a', 'n', 's', 'A', 'x', 'i', 's', 0,
    'v', '_', 'b', 'a', 's', 'e', '_', 'A', 'B', 0,
    'I', 'n', 't', 'e', 'g', 'r', 'a', 't', 'e', 0,
    'f', 'r', 'e', 'q', 'u', 'e', 'n', 'c', 'y', 0,
    'S', 'e', 't', 'T', 'o', 'Z', 'e', 'r', 'o', 0,
    'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'e', 0,
    'c', 'o', 'r', 'i', 'o', 'l', 'i', 's', 0,
    'T', 'w', 'i', 's', 't', 'V', 'e', 'l', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 0,
    'G', 'e', 't', 'F', 'r', 'a', 'm', 'e', 0,
    'F', 'r', 'a', 'm', 'e', 'V', 'e', 'l', 0,
    'q', '_', 'd', 'o', 't', 'd', 'o', 't', 0,
    'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 0,
    'g', 'e', 't', 'A', 'l', 'p', 'h', 'a', 0,
    's', 'e', 't', 'A', 'l', 'p', 'h', 'a', 0,
    '_', 'm', 'a', 'x', 'i', 't', 'e', 'r', 0,
    'i', 'k', 's', 'o', 'l', 'v', 'e', 'r', 0,
    'f', 'k', 's', 'o', 'l', 'v', 'e', 'r', 0,
    'q', 'd', 'o', 't', '_', 'o', 'u', 't', 0,
    's', 't', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'g', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 0,
    'S', 'u', 'b', 't', 'r', 'a', 'c', 't', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 0,
    'g', 'e', 't', 'C', 'h', 'a', 'i', 'n', 0,
    'a', 'd', 'd', 'C', 'h', 'a', 'i', 'n', 0,
    'g', 'e', 't', 'J', 'o', 'i', 'n', 't', 0,
    'a', 'd', 'd', 'D', 'e', 'l', 't', 'a', 0,
    'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    '_', '_', 'i', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'i', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'r', 'e', 'p', 'r', '_', '_', 0,
    'g', 'r', 'a', 'v', 'i', 't', 'y', 0,
    't', 'o', 'r', 'q', 'u', 'e', 's', 0,
    'o', 'p', 't', '_', 'p', 'o', 's', 0,
    'w', 'e', 'i', 'g', 'h', 't', 's', 0,
    'S', 'o', 'l', 'v', 'e', 'r', 'I', 0,
    'n', 'e', 'w', 'S', 'i', 'z', 'e', 0,
    'c', 'o', 'l', 'u', 'm', 'n', 's', 0,
    's', 'e', 'g', 'm', 'e', 'n', 't', 0,
    'g', 'e', 't', 'M', 'a', 's', 's', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'a', 'm', 'e', 0,
    'd', 'a', 'm', 'p', 'i', 'n', 'g', 0,
    'i', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'R', 'o', 't', 'A', 'x', 'i', 's', 0,
    '_', '_', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'd', 'i', 'v', '_', '_', 0,
    '_', '_', 'm', 'u', 'l', '_', '_', 0,
    '_', '_', 'n', 'e', 'g', '_', '_', 0,
    'm', 'a', 't', 'r', 'i', 'x', 0,
    'r', 'o', 't', 'v', 'e', 'c', 0,
    's', 'e', 'g', '_', 'n', 'r', 0,
    'l', 'a', 'm', 'b', 'd', 'a', 0,
    'q', '_', 'i', 'n', 'i', 't', 0,
    'D', 'i', 'v', 'i', 'd', 'e', 0,
    'f', 'a', 'c', 't', 'o', 'r', 0,
    'r', 'e', 's', 'i', 'z', 'e', 0,
    'g', 'e', 't', 'C', 'O', 'G', 0,
    'o', 'r', 'i', 'g', 'i', 'n', 0,
    'o', 'f', 'f', 's', 'e', 't', 0,
    'T', 'r', 'a', 'n', 's', 'Z', 0,
    'T', 'r', 'a', 'n', 's', 'Y', 0,
    'T', 'r', 'a', 'n', 's', 'X', 0,
    'W', '_', 'a', '_', 'p', '2', 0,
    'W', '_', 'a', '_', 'p', '1', 0,
    'F', '_', 'a', '_', 'b', '2', 0,
    'F', '_', 'a', '_', 'b', '1', 0,
    'R', '_', 'a', '_', 'b', '2', 0,
    'R', '_', 'a', '_', 'b', '1', 0,
    't', 'o', 'r', 'q', 'u', 'e', 0,
    'W', 'r', 'e', 'n', 'c', 'h', 0,
    't', '_', 't', 'h', 'i', 's', 0,
    'G', 'e', 't', 'R', 'P', 'Y', 0,
    'G', 'e', 't', 'R', 'o', 't', 0,
    'D', 'o', 'R', 'o', 't', 'Z', 0,
    'D', 'o', 'R', 'o', 't', 'Y', 0,
    'D', 'o', 'R', 'o', 't', 'X', 0,
    '_', '_', 'n', 'e', '_', '_', 0,
    '_', '_', 'e', 'q', '_', '_', 0,
    'V', 'e', 'c', 't', 'o', 'r', 0,
    '_', 'g', 'r', 'a', 'v', 0,
    'f', '_', 'e', 'x', 't', 0,
    'q', '_', 'd', 'o', 't', 0,
    'q', '_', 'm', 'a', 'x', 0,
    'q', '_', 'm', 'i', 'n', 0,
    'q', '_', 'o', 'u', 't', 0,
    'p', '_', 'o', 'u', 't', 0,
    'f', 'r', 'a', 'm', 'e', 0,
    'd', 'e', 'r', 'i', 'v', 0,
    'a', 'r', 'r', 'a', 'y', 0,
    'c', 'h', 'a', 'i', 'n', 0,
    'f', '_', 't', 'i', 'p', 0,
    'j', 'o', 'i', 'n', 't', 0,
    't', 'w', 'i', 's', 't', 0,
    's', 'c', 'a', 'l', 'e', 0,
    'f', 'o', 'r', 'c', 'e', 0,
    't', 'h', 'e', 't', 'a', 0,
    'a', 'l', 'p', 'h', 'a', 0,
    'U', 'n', 'i', 't', 'Z', 0,
    'U', 'n', 'i', 't', 'Y', 0,
    'U', 'n', 'i', 't', 'X', 0,
    'g', 'a', 'm', 'm', 'a', 0,
    'p', 'i', 't', 'c', 'h', 0,
    'G', 'a', 'm', 'm', 'a', 0,
    'a', 'n', 'g', 'l', 'e', 0,
    'E', 'q', 'u', 'a', 'l', 0,
    'v', 'a', 'l', 'u', 'e', 0,
    'P', 'y', 'K', 'D', 'L', 0,
    'g', 'r', 'a', 'd', 0,
    'v', '_', 'i', 'n', 0,
    'p', '_', 'i', 'n', 0,
    'q', '_', 'i', 'n', 0,
    'd', 'e', 's', 't', 0,
    's', 'r', 'c', '2', 0,
    's', 'r', 'c', '1', 0,
    'r', 'o', 'w', 's', 0,
    'T', 'r', 'e', 'e', 0,
    'q', 'd', 'o', 't', 0,
    'p', 'o', 's', 'e', 0,
    't', 'y', 'p', 'e', 0,
    'N', 'o', 'n', 'e', 0,
    'd', 'i', 'f', 'f', 0,
    '_', 'r', 'o', 't', 0,
    '_', 'v', 'e', 'l', 0,
    'b', 'e', 't', 'a', 0,
    'a', 'l', 'f', 'a', 0,
    'a', 'x', 'i', 's', 0,
    'r', 'o', 'l', 'l', 0,
    'B', 'e', 't', 'a', 0,
    'A', 'l', 'f', 'a', 0,
    'R', 'o', 't', '2', 0,
    'N', 'o', 'r', 'm', 0,
    'j', 'a', 'c', 0,
    's', 'r', 'c', 0,
    'A', 'd', 'd', 0,
    'I', 'i', 'n', 0,
    'I', 'y', 'z', 0,
    'I', 'x', 'z', 0,
    'I', 'x', 'y', 0,
    'I', 'z', 'z', 0,
    'I', 'y', 'y', 0,
    'I', 'x', 'x', 0,
    'y', 'a', 'w', 0,
    'r', 'h', 's', 0,
    'l', 'h', 's', 0,
    'e', 'p', 's', 0,
    'a', 'r', 'g', 0,
    '_', 'M', 0,
    '_', 't', 0,
    '_', 'T', 0,
    '_', 'w', 0,
    '_', 'R', 0,
    '_', 'v', 0,
    '_', 'p', 0,
    'r', '2', 0,
    'r', '1', 0,
    'I', 'c', 0,
    'o', 'c', 0,
    'd', 't', 0,
    'D', 'H', 0,
    'Z', 'z', 0,
    'Y', 'z', 0,
    'X', 'z', 0,
    'Z', 'y', 0,
    'Y', 'y', 0,
    'X', 'y', 0,
    'Z', 'x', 0,
    'Y', 'x', 0,
    'X', 'x', 0,
    'q', 0,
    'i', 0,
    'V', 0,
    'b', 0,
};

int sipVH_PyKDL_10(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::JntArray& a1,const  ::JntArray& a2,const std::vector< ::Wrench>& a3, ::JntArray& a4)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NNNND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::JntArray(a1), sipType_JntArray, NULL, new  ::JntArray(a2), sipType_JntArray, NULL, new std::vector< ::Wrench>(a3), sipType_std_vector_0100Wrench, NULL, &a4, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_9(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const double a0)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "d", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_8(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "N", new  ::JntArray(a0), sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_7(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::FrameVel& a1, ::JntArrayVel& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::FrameVel(a1), sipType_FrameVel, NULL, &a2, sipType_JntArrayVel, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_6(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::Twist(a1), sipType_Twist, NULL, &a2, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_5(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::Frame(a1), sipType_Frame, NULL, &a2, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_4(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArrayVel& a0, ::FrameVel& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi", new  ::JntArrayVel(a0), sipType_JntArrayVel, NULL, &a1, sipType_FrameVel, NULL, a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_3(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0, ::Frame& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi", new  ::JntArray(a0), sipType_JntArray, NULL, &a1, sipType_Frame, NULL, a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

void sipVH_PyKDL_2(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "");
}

const char* sipVH_PyKDL_1(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const int a0, int sipResKey)
{
    char* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "i", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "B", sipResKey, &sipRes);

    return sipRes;
}

int sipVH_PyKDL_0(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}


PyDoc_STRVAR(doc_changeRefFrame, "changeRefFrame(src1: Jacobian, frame: Frame, dest: Jacobian)");

extern "C" {static PyObject *func_changeRefFrame(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeRefFrame(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Frame* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_frame,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Frame, &a1, sipType_Jacobian, &a2))
        {
            changeRefFrame(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefFrame, doc_changeRefFrame);

    return NULL;
}


PyDoc_STRVAR(doc_changeBase, "changeBase(src1: Jacobian, rot: Rotation, dest: Jacobian)");

extern "C" {static PyObject *func_changeBase(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeBase(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Rotation* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_rot,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Rotation, &a1, sipType_Jacobian, &a2))
        {
            changeBase(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeBase, doc_changeBase);

    return NULL;
}


PyDoc_STRVAR(doc_changeRefPoint, "changeRefPoint(src1: Jacobian, base_AB: Vector, dest: Jacobian)");

extern "C" {static PyObject *func_changeRefPoint(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeRefPoint(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Vector* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_base_AB,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Vector, &a1, sipType_Jacobian, &a2))
        {
            changeRefPoint(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefPoint, doc_changeRefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_MultiplyJacobian, "MultiplyJacobian(jac: Jacobian, src: JntArray, dest: Twist)");

extern "C" {static PyObject *func_MultiplyJacobian(PyObject *,PyObject *, PyObject *);}
static PyObject *func_MultiplyJacobian(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::JntArray* a1;
         ::Twist* a2;

        static const char *sipKwdList[] = {
            sipName_jac,
            sipName_src,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_JntArray, &a1, sipType_Twist, &a2))
        {
            MultiplyJacobian(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_MultiplyJacobian, doc_MultiplyJacobian);

    return NULL;
}


PyDoc_STRVAR(doc_Divide, "Divide(src: JntArray, factor: float, dest: JntArray)\n"
"Divide(src: JntArrayVel, factor: float, dest: JntArrayVel)\n"
"Divide(src: JntArrayVel, factor: doubleVel, dest: JntArrayVel)\n"
"Divide(src: JntSpaceInertiaMatrix, factor: float, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Divide(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Divide(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        double a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        double a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::doubleVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        double a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Divide, doc_Divide);

    return NULL;
}


PyDoc_STRVAR(doc_Multiply, "Multiply(src: JntArray, factor: float, dest: JntArray)\n"
"Multiply(src: JntArrayVel, factor: float, dest: JntArrayVel)\n"
"Multiply(src: JntArrayVel, factor: doubleVel, dest: JntArrayVel)\n"
"Multiply(src: JntSpaceInertiaMatrix, factor: float, dest: JntSpaceInertiaMatrix)\n"
"Multiply(src: JntSpaceInertiaMatrix, vec: JntArray, dest: JntArray)");

extern "C" {static PyObject *func_Multiply(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Multiply(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        double a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        double a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::doubleVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        double a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_vec,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Multiply, doc_Multiply);

    return NULL;
}


PyDoc_STRVAR(doc_Subtract, "Subtract(src1: JntArray, src2: JntArray, dest: JntArray)\n"
"Subtract(src1: JntArrayVel, src2: JntArrayVel, dest: JntArrayVel)\n"
"Subtract(src1: JntArrayVel, src2: JntArray, dest: JntArrayVel)\n"
"Subtract(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Subtract(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Subtract(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArray* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Subtract, doc_Subtract);

    return NULL;
}


PyDoc_STRVAR(doc_Add, "Add(src1: JntArray, src2: JntArray, dest: JntArray)\n"
"Add(src1: JntArrayVel, src2: JntArrayVel, dest: JntArrayVel)\n"
"Add(src1: JntArrayVel, src2: JntArray, dest: JntArrayVel)\n"
"Add(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Add(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Add(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArray* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Add, doc_Add);

    return NULL;
}


PyDoc_STRVAR(doc_addDelta, "addDelta(a: Vector, da: Vector, dt: float = 1) -> Vector\n"
"addDelta(a: Rotation, da: Vector, dt: float = 1) -> Rotation\n"
"addDelta(a: Frame, da: Twist, dt: float = 1) -> Frame\n"
"addDelta(a: Twist, da: Twist, dt: float = 1) -> Twist\n"
"addDelta(a: Wrench, da: Wrench, dt: float = 1) -> Wrench\n"
"addDelta(a: doubleVel, da: doubleVel, dt: float = 1) -> doubleVel\n"
"addDelta(a: VectorVel, da: VectorVel, dt: float = 1) -> VectorVel\n"
"addDelta(a: RotationVel, da: VectorVel, dt: float = 1) -> RotationVel\n"
"addDelta(a: FrameVel, da: TwistVel, dt: float = 1) -> FrameVel");

extern "C" {static PyObject *func_addDelta(PyObject *,PyObject *, PyObject *);}
static PyObject *func_addDelta(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Vector, &a1, &a2))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Twist, &a1, &a2))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::TwistVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_TwistVel, &a1, &a2))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_addDelta, doc_addDelta);

    return NULL;
}


PyDoc_STRVAR(doc_diff, "diff(a: Vector, b: Vector, dt: float = 1) -> Vector\n"
"diff(R_a_b1: Rotation, R_a_b2: Rotation, dt: float = 1) -> Vector\n"
"diff(F_a_b1: Frame, F_a_b2: Frame, dt: float = 1) -> Twist\n"
"diff(a: Twist, b: Twist, dt: float = 1) -> Twist\n"
"diff(W_a_p1: Wrench, W_a_p2: Wrench, dt: float = 1) -> Wrench\n"
"diff(a: doubleVel, b: doubleVel, dt: float = 1) -> doubleVel\n"
"diff(a: VectorVel, b: VectorVel, dt: float = 1) -> VectorVel\n"
"diff(a: RotationVel, b: RotationVel, dt: float = 1) -> VectorVel\n"
"diff(a: FrameVel, b: FrameVel, dt: float = 1) -> TwistVel");

extern "C" {static PyObject *func_diff(PyObject *,PyObject *, PyObject *);}
static PyObject *func_diff(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Rotation* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_R_a_b1,
            sipName_R_a_b2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Frame* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_F_a_b1,
            sipName_F_a_b2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_W_a_p1,
            sipName_W_a_p2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::RotationVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_diff, doc_diff);

    return NULL;
}


PyDoc_STRVAR(doc_Equal, "Equal(a: Vector, b: Vector, eps: float = epsilon) -> bool\n"
"Equal(a: Rotation, b: Rotation, eps: float = epsilon) -> bool\n"
"Equal(a: Frame, b: Frame, eps: float = epsilon) -> bool\n"
"Equal(a: Twist, b: Twist, eps: float = epsilon) -> bool\n"
"Equal(a: Wrench, b: Wrench, eps: float = epsilon) -> bool\n"
"Equal(src1: JntArray, src2: JntArray, eps: float = epsilon) -> bool\n"
"Equal(src1: JntArrayVel, src2: JntArrayVel, eps: float = epsilon) -> bool\n"
"Equal(r1: doubleVel, r2: doubleVel, eps: float = epsilon) -> bool\n"
"Equal(r1: VectorVel, r2: VectorVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Vector, r2: VectorVel, eps: float = epsilon) -> bool\n"
"Equal(r1: VectorVel, r2: Vector, eps: float = epsilon) -> bool\n"
"Equal(r1: RotationVel, r2: RotationVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Rotation, r2: RotationVel, eps: float = epsilon) -> bool\n"
"Equal(r1: RotationVel, r2: Rotation, eps: float = epsilon) -> bool\n"
"Equal(r1: FrameVel, r2: FrameVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Frame, r2: FrameVel, eps: float = epsilon) -> bool\n"
"Equal(r1: FrameVel, r2: Frame, eps: float = epsilon) -> bool\n"
"Equal(a: TwistVel, b: TwistVel, eps: float = epsilon) -> bool\n"
"Equal(a: Twist, b: TwistVel, eps: float = epsilon) -> bool\n"
"Equal(a: TwistVel, b: Twist, eps: float = epsilon) -> bool\n"
"Equal(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, eps: float = epsilon) -> bool");

extern "C" {static PyObject *func_Equal(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Equal(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Rotation* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Frame* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntArray, &a0, sipType_JntArray, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::RotationVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::RotationVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::Rotation* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Frame* a0;
        const  ::FrameVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::Frame* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_TwistVel, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::TwistVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::Twist* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_TwistVel, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Equal, doc_Equal);

    return NULL;
}


PyDoc_STRVAR(doc_dot, "dot(lhs: Vector, rhs: Vector) -> float\n"
"dot(lhs: Twist, rhs: Wrench) -> float\n"
"dot(rhs: Wrench, lhs: Twist) -> float\n"
"dot(lhs: VectorVel, rhs: VectorVel) -> doubleVel\n"
"dot(lhs: VectorVel, rhs: Vector) -> doubleVel\n"
"dot(lhs: Vector, rhs: VectorVel) -> doubleVel");

extern "C" {static PyObject *func_dot(PyObject *,PyObject *, PyObject *);}
static PyObject *func_dot(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Wrench* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Twist, &a0, sipType_Wrench, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName_rhs,
            sipName_lhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Wrench, &a0, sipType_Twist, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dot, doc_dot);

    return NULL;
}


PyDoc_STRVAR(doc_SetToZero, "SetToZero(v: Vector)\n"
"SetToZero(v: Twist)\n"
"SetToZero(v: Wrench)\n"
"SetToZero(array: JntArray)\n"
"SetToZero(array: JntArrayVel)\n"
"SetToZero(jac: Jacobian)\n"
"SetToZero(v: TwistVel)\n"
"SetToZero(matrix: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_SetToZero(PyObject *,PyObject *, PyObject *);}
static PyObject *func_SetToZero(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::Vector* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Vector, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Twist* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Twist, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Wrench* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Wrench, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_array,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntArray, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntArrayVel* a0;

        static const char *sipKwdList[] = {
            sipName_array,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntArrayVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Jacobian* a0;

        static const char *sipKwdList[] = {
            sipName_jac,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Jacobian, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::TwistVel* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_TwistVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntSpaceInertiaMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_matrix,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_SetToZero, doc_SetToZero);

    return NULL;
}
static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_Joint__JointType, {0}, 0}, sipNameNr_JointType, 25, NULL},
};


/*
 * This defines each type in this module.
 */
sipTypeDef *sipExportedTypes_PyKDL[] = {
    &sipTypeDef_PyKDL_Chain.ctd_base,
    &sipTypeDef_PyKDL_ChainDynParam.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainIdSolver.ctd_base,
    &sipTypeDef_PyKDL_ChainIdSolver_RNE.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_LMA.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_givens.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_wdls.ctd_base,
    &sipTypeDef_PyKDL_ChainJntToJacDotSolver.ctd_base,
    &sipTypeDef_PyKDL_ChainJntToJacSolver.ctd_base,
    &sipTypeDef_PyKDL_Frame.ctd_base,
    &sipTypeDef_PyKDL_FrameVel.ctd_base,
    &sipTypeDef_PyKDL_Jacobian.ctd_base,
    &sipTypeDef_PyKDL_JntArray.ctd_base,
    &sipTypeDef_PyKDL_JntArrayVel.ctd_base,
    &sipTypeDef_PyKDL_JntSpaceInertiaMatrix.ctd_base,
    &sipTypeDef_PyKDL_Joint.ctd_base,
    &enumTypes[0].etd_base,
    &sipTypeDef_PyKDL_RigidBodyInertia.ctd_base,
    &sipTypeDef_PyKDL_Rotation.ctd_base,
    &sipTypeDef_PyKDL_RotationVel.ctd_base,
    &sipTypeDef_PyKDL_RotationalInertia.ctd_base,
    &sipTypeDef_PyKDL_Segment.ctd_base,
    &sipTypeDef_PyKDL_SolverI.ctd_base,
    &sipTypeDef_PyKDL_Tree.ctd_base,
    &sipTypeDef_PyKDL_Twist.ctd_base,
    &sipTypeDef_PyKDL_TwistVel.ctd_base,
    &sipTypeDef_PyKDL_Vector.ctd_base,
    &sipTypeDef_PyKDL_VectorVel.ctd_base,
    &sipTypeDef_PyKDL_Wrench.ctd_base,
    &sipTypeDef_PyKDL_doubleVel.ctd_base,
    &sipTypeDef_PyKDL_std_string.mtd_base,
    &sipTypeDef_PyKDL_std_vector_0100Wrench.mtd_base,
};


/*
 * These define each typedef in this module.
 */
static sipTypedefDef typedefsTable[] = {
    {"doubleVel::doubleVel", "Rall1d<double>"},
};


/* Define the module's license. */
static sipLicenseDef module_license = {
    "LGPL",
    "Ruben Smits",
    "2014",
    "ruben@intermodalics.eu"
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_PyKDL = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_PyKDL,
    0,
    sipStrings_PyKDL,
    NULL,
    NULL,
    42,
    sipExportedTypes_PyKDL,
    NULL,
    0,
    NULL,
    1,
    typedefsTable,
    NULL,
    NULL,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    &module_license,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_PyKDL;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_PyKDL
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initPyKDL
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_MLNAME_CAST(sipName_changeRefFrame), (PyCFunction)func_changeRefFrame, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeRefFrame)},
        {SIP_MLNAME_CAST(sipName_changeBase), (PyCFunction)func_changeBase, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeBase)},
        {SIP_MLNAME_CAST(sipName_changeRefPoint), (PyCFunction)func_changeRefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeRefPoint)},
        {SIP_MLNAME_CAST(sipName_MultiplyJacobian), (PyCFunction)func_MultiplyJacobian, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_MultiplyJacobian)},
        {SIP_MLNAME_CAST(sipName_Divide), (PyCFunction)func_Divide, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Divide)},
        {SIP_MLNAME_CAST(sipName_Multiply), (PyCFunction)func_Multiply, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Multiply)},
        {SIP_MLNAME_CAST(sipName_Subtract), (PyCFunction)func_Subtract, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Subtract)},
        {SIP_MLNAME_CAST(sipName_Add), (PyCFunction)func_Add, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Add)},
        {SIP_MLNAME_CAST(sipName_addDelta), (PyCFunction)func_addDelta, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_addDelta)},
        {SIP_MLNAME_CAST(sipName_diff), (PyCFunction)func_diff, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_diff)},
        {SIP_MLNAME_CAST(sipName_Equal), (PyCFunction)func_Equal, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Equal)},
        {SIP_MLNAME_CAST(sipName_dot), (PyCFunction)func_dot, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_dot)},
        {SIP_MLNAME_CAST(sipName_SetToZero), (PyCFunction)func_SetToZero, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_SetToZero)},
        {0, 0, 0, 0}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "PyKDL",
        NULL,
        -1,
        sip_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_PyKDL, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_PyKDL), sip_methods);
#endif

    if (sipModule == NULL)
        SIP_MODULE_RETURN(NULL);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule(SIP_MODULE_NAME);
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>(SIP_MODULE_NAME));
#endif

    if (sip_sipmod == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");
    Py_DECREF(sip_sipmod);

#if defined(SIP_USE_PYCAPSULE)
    if (sip_capiobj == NULL || !PyCapsule_CheckExact(sip_capiobj))
#else
    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
#endif
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

#if defined(SIP_USE_PYCAPSULE)
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCapsule_GetPointer(sip_capiobj, SIP_MODULE_NAME "._C_API"));
#else
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));
#endif

#if defined(SIP_USE_PYCAPSULE)
    if (sipAPI_PyKDL == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }
#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_PyKDL,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_PyKDL,sipModuleDict) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }

    SIP_MODULE_RETURN(sipModule);
}

#line 27 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 2496 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 2503 "sip_PyKDL/sipPyKDLpart0.cpp"


extern "C" {static void assign_std_vector_0100Wrench(void *, SIP_SSIZE_T, void *);}
static void assign_std_vector_0100Wrench(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<std::vector< ::Wrench> *>(sipDst)[sipDstIdx] = *reinterpret_cast<std::vector< ::Wrench> *>(sipSrc);
}


extern "C" {static void *array_std_vector_0100Wrench(SIP_SSIZE_T);}
static void *array_std_vector_0100Wrench(SIP_SSIZE_T sipNrElem)
{
    return new std::vector< ::Wrench>[sipNrElem];
}


extern "C" {static void *copy_std_vector_0100Wrench(const void *, SIP_SSIZE_T);}
static void *copy_std_vector_0100Wrench(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new std::vector< ::Wrench>(reinterpret_cast<const std::vector< ::Wrench> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_std_vector_0100Wrench(void *, int);}
static void release_std_vector_0100Wrench(void *ptr, int)
{
    delete reinterpret_cast<std::vector< ::Wrench> *>(ptr);
}



extern "C" {static int convertTo_std_vector_0100Wrench(PyObject *, void **, int *, PyObject *);}
static int convertTo_std_vector_0100Wrench(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    std::vector< ::Wrench> **sipCppPtr = reinterpret_cast<std::vector< ::Wrench> **>(sipCppPtrV);

#line 60 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    // Check if type is compatible
    if (!sipIsErr) {
        // Must be any iterable
        PyObject *i = PyObject_GetIter(sipPy);
        bool iterable = (i != NULL);
        Py_XDECREF(i);
        return iterable;
    }

    // Iterate over the object
    PyObject *iterator = PyObject_GetIter(sipPy);
    PyObject *item;

    std::vector<Wrench> *V = new std::vector<Wrench>();

    while ((item = PyIter_Next(iterator)))
    {
        if (!sipCanConvertToInstance(item, sipClass_Wrench, SIP_NOT_NONE)) {
            PyErr_Format(PyExc_TypeError, "object in iterable cannot be converted to Wrench");
            *sipIsErr = 1;
            break;
        }

        int state;
        Wrench* p = reinterpret_cast<Wrench*>(
             sipConvertToInstance(item, sipClass_Wrench, 0, SIP_NOT_NONE, &state, sipIsErr));

        if (!*sipIsErr)
            V->push_back(*p);

        sipReleaseInstance(p, sipClass_Wrench, state);
        Py_DECREF(item);
    }

    Py_DECREF(iterator);

    if (*sipIsErr) {
        delete V;
        return 0;
    }

    *sipCppPtr = V;
    return sipGetState(sipTransferObj);
#line 2585 "sip_PyKDL/sipPyKDLpart0.cpp"
}


extern "C" {static PyObject *convertFrom_std_vector_0100Wrench(void *, PyObject *);}
static PyObject *convertFrom_std_vector_0100Wrench(void *sipCppV, PyObject *sipTransferObj)
{
   std::vector< ::Wrench> *sipCpp = reinterpret_cast<std::vector< ::Wrench> *>(sipCppV);

#line 31 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    PyObject *l = PyList_New(sipCpp -> size());

    // Create the Python list of the correct length.
    if (!l)
        return NULL;

    // Go through each element in the C++ instance and convert it to a
    // wrapped P2d.
    for (int i = 0; i < (int)sipCpp->size(); ++i) {
        Wrench *cpp = new Wrench(sipCpp->at(i));
        PyObject *pobj = sipConvertFromInstance(cpp, sipClass_Wrench, sipTransferObj);

        // Get the Python wrapper for the Type instance, creating a new
        // one if necessary, and handle any ownership transfer.
        if (!pobj) {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        // Add the wrapper to the list.
        PyList_SET_ITEM(l, i, pobj);
    }

    // Return the Python list.
    return l;
#line 2621 "sip_PyKDL/sipPyKDLpart0.cpp"
}


sipMappedTypeDef sipTypeDef_PyKDL_std_vector_0100Wrench = {
    {
        -1,
        0,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_292,     /* std::vector<Wrench> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_std_vector_0100Wrench,
    array_std_vector_0100Wrench,
    copy_std_vector_0100Wrench,
    release_std_vector_0100Wrench,
    convertTo_std_vector_0100Wrench,
    convertFrom_std_vector_0100Wrench
};

#line 65 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/chaindynparam.hpp>
using namespace KDL;
#line 2654 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 2659 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 2665 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 2669 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 2673 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_ChainDynParam_JntToCoriolis, "JntToCoriolis(self, q: JntArray, q_dot: JntArray, coriolis: JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_q_dot,
            sipName_coriolis,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToCoriolis(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToCoriolis, doc_ChainDynParam_JntToCoriolis);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToMass, "JntToMass(self, q: JntArray, H: JntSpaceInertiaMatrix) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToMass(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToMass(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::JntSpaceInertiaMatrix* a1;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_H,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntSpaceInertiaMatrix, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToMass(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToMass, doc_ChainDynParam_JntToMass);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToGravity, "JntToGravity(self, q: JntArray, gravity: JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToGravity(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToGravity(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::JntArray* a1;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_gravity,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToGravity(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToGravity, doc_ChainDynParam_JntToGravity);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainDynParam(void *, int);}
static void release_ChainDynParam(void *sipCppV, int)
{
    delete reinterpret_cast< ::ChainDynParam *>(sipCppV);
}


extern "C" {static void dealloc_ChainDynParam(sipSimpleWrapper *);}
static void dealloc_ChainDynParam(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainDynParam(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::ChainDynParam *sipCpp = 0;

    {
        const  ::Chain* a0;
         ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName__grav,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Chain, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::ChainDynParam(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::ChainDynParam* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainDynParam, &a0))
        {
            sipCpp = new  ::ChainDynParam(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_ChainDynParam[] = {
    {SIP_MLNAME_CAST(sipName_JntToCoriolis), (PyCFunction)meth_ChainDynParam_JntToCoriolis, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToCoriolis)},
    {SIP_MLNAME_CAST(sipName_JntToGravity), (PyCFunction)meth_ChainDynParam_JntToGravity, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToGravity)},
    {SIP_MLNAME_CAST(sipName_JntToMass), (PyCFunction)meth_ChainDynParam_JntToMass, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToMass)}
};

PyDoc_STRVAR(doc_ChainDynParam, "\1ChainDynParam(chain: Chain, _grav: Vector)\n"
"ChainDynParam(ChainDynParam)");


sipClassTypeDef sipTypeDef_PyKDL_ChainDynParam = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainDynParam,
        {0},
        0
    },
    {
        sipNameNr_ChainDynParam,
        {0, 0, 1},
        3, methods_ChainDynParam,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainDynParam,
    -1,
    -1,
    0,
    0,
    init_type_ChainDynParam,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainDynParam,
    0,
    0,
    0,
    release_ChainDynParam,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 2902 "sip_PyKDL/sipPyKDLpart0.cpp"



PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_resize, "resize(self, newSize: int)");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::JntSpaceInertiaMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_resize, doc_JntSpaceInertiaMatrix_resize);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_rows, "rows(self) -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_rows, doc_JntSpaceInertiaMatrix_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_columns, "columns(self) -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_columns, doc_JntSpaceInertiaMatrix_columns);

    return NULL;
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_JntSpaceInertiaMatrix, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_JntSpaceInertiaMatrix, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 39 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > (int)sipCpp->rows() || j >= (int)sipCpp->columns()) {
        PyErr_SetString(PyExc_IndexError, "Inertia index out of range");
        return NULL;
    }
    sipRes=(*sipCpp)(i,j);
#line 3083 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntSpaceInertiaMatrix(void *, int);}
static void release_JntSpaceInertiaMatrix(void *sipCppV, int)
{
    delete reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipCppV);
}


extern "C" {static void assign_JntSpaceInertiaMatrix(void *, SIP_SSIZE_T, void *);}
static void assign_JntSpaceInertiaMatrix(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipSrc);
}


extern "C" {static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T);}
static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T sipNrElem)
{
    return new  ::JntSpaceInertiaMatrix[sipNrElem];
}


extern "C" {static void *copy_JntSpaceInertiaMatrix(const void *, SIP_SSIZE_T);}
static void *copy_JntSpaceInertiaMatrix(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::JntSpaceInertiaMatrix(reinterpret_cast<const  ::JntSpaceInertiaMatrix *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *);}
static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_JntSpaceInertiaMatrix(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::JntSpaceInertiaMatrix *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix();

            return sipCpp;
        }
    }

    {
        int a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "i", &a0))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix(a0);

            return sipCpp;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntSpaceInertiaMatrix[] = {
    {(void *)slot_JntSpaceInertiaMatrix___ne__, ne_slot},
    {(void *)slot_JntSpaceInertiaMatrix___eq__, eq_slot},
    {(void *)slot_JntSpaceInertiaMatrix___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntSpaceInertiaMatrix[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntSpaceInertiaMatrix_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_columns)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntSpaceInertiaMatrix_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntSpaceInertiaMatrix_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_rows)}
};

PyDoc_STRVAR(doc_JntSpaceInertiaMatrix, "\1JntSpaceInertiaMatrix()\n"
"JntSpaceInertiaMatrix(size: int)\n"
"JntSpaceInertiaMatrix(arg: JntSpaceInertiaMatrix)");


sipClassTypeDef sipTypeDef_PyKDL_JntSpaceInertiaMatrix = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntSpaceInertiaMatrix,
        {0},
        0
    },
    {
        sipNameNr_JntSpaceInertiaMatrix,
        {0, 0, 1},
        3, methods_JntSpaceInertiaMatrix,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntSpaceInertiaMatrix,
    -1,
    -1,
    0,
    slots_JntSpaceInertiaMatrix,
    init_type_JntSpaceInertiaMatrix,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntSpaceInertiaMatrix,
    assign_JntSpaceInertiaMatrix,
    array_JntSpaceInertiaMatrix,
    copy_JntSpaceInertiaMatrix,
    release_JntSpaceInertiaMatrix,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 207 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3258 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3263 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 3269 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3273 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_TwistVel_value, "value(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_value(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_value, doc_TwistVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_deriv, "deriv(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_deriv, doc_TwistVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_Zero, "Zero() -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel( ::TwistVel::Zero());

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_Zero, doc_TwistVel_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_TwistVel_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_ReverseSign, doc_TwistVel_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_RefPoint, "RefPoint(self, v_base_AB: VectorVel) -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_TwistVel_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
         ::TwistVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_v_base_AB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_TwistVel, &sipCpp, sipType_VectorVel, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_RefPoint, doc_TwistVel_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwist, "GetTwist(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwist, doc_TwistVel_GetTwist);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwistDot, "GetTwistDot(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwistDot(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwistDot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwistDot());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwistDot, doc_TwistVel_GetTwistDot);

    return NULL;
}


extern "C" {static PyObject *slot_TwistVel___neg__(PyObject *);}
static PyObject *slot_TwistVel___neg__(PyObject *sipSelf)
{
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;


    {
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_TwistVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        double a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___div__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 / *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___add__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___sub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___iadd__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp-> ::TwistVel::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_TwistVel___isub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp-> ::TwistVel::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_TwistVel(void *, int);}
static void release_TwistVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::TwistVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_TwistVel(void *);}
static PyObject *pickle_TwistVel(void *sipCppV)
{
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipCppV);
    PyObject *sipRes;

#line 233 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->vel), vectorvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->rot), vectorvel_type, Py_None));
#line 3749 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_TwistVel(void *, SIP_SSIZE_T, void *);}
static void assign_TwistVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::TwistVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::TwistVel *>(sipSrc);
}


extern "C" {static void *array_TwistVel(SIP_SSIZE_T);}
static void *array_TwistVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::TwistVel[sipNrElem];
}


extern "C" {static void *copy_TwistVel(const void *, SIP_SSIZE_T);}
static void *copy_TwistVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::TwistVel(reinterpret_cast<const  ::TwistVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_TwistVel(sipSimpleWrapper *);}
static void dealloc_TwistVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_TwistVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::TwistVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::TwistVel();

            return sipCpp;
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName__vel,
            sipName__rot,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new  ::TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName_p,
            sipName_v,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Twist, &a0, sipType_Twist, &a1))
        {
            sipCpp = new  ::TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Twist* a0;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Twist, &a0))
        {
            sipCpp = new  ::TwistVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::TwistVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_TwistVel, &a0))
        {
            sipCpp = new  ::TwistVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_TwistVel[] = {
    {(void *)slot_TwistVel___neg__, neg_slot},
    {(void *)slot_TwistVel___mul__, mul_slot},
    {(void *)slot_TwistVel___div__, div_slot},
    {(void *)slot_TwistVel___add__, add_slot},
    {(void *)slot_TwistVel___sub__, sub_slot},
    {(void *)slot_TwistVel___iadd__, iadd_slot},
    {(void *)slot_TwistVel___isub__, isub_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_TwistVel[] = {
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_TwistVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_GetTwistDot), meth_TwistVel_GetTwistDot, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwistDot)},
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_TwistVel_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_TwistVel_RefPoint)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_TwistVel_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_TwistVel_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_Zero)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_TwistVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_TwistVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_value)}
};


extern "C" {static PyObject *varget_TwistVel_rot(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_rot(void *sipSelf, PyObject *, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    sipVal = &sipCpp->rot;

    return sipConvertFromType(sipVal, sipType_VectorVel, NULL);
}


extern "C" {static int varset_TwistVel_rot(void *, PyObject *, PyObject *);}
static int varset_TwistVel_rot(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->rot = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_TwistVel_vel(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_vel(void *sipSelf, PyObject *, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    sipVal = &sipCpp->vel;

    return sipConvertFromType(sipVal, sipType_VectorVel, NULL);
}


extern "C" {static int varset_TwistVel_vel(void *, PyObject *, PyObject *);}
static int varset_TwistVel_vel(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->vel = *sipVal;

    return 0;
}

sipVariableDef variables_TwistVel[] = {
    {InstanceVariable, sipName_rot, (PyMethodDef *)varget_TwistVel_rot, (PyMethodDef *)varset_TwistVel_rot, NULL, NULL},
    {InstanceVariable, sipName_vel, (PyMethodDef *)varget_TwistVel_vel, (PyMethodDef *)varset_TwistVel_vel, NULL, NULL},
};

PyDoc_STRVAR(doc_TwistVel, "\1TwistVel()\n"
"TwistVel(_vel: VectorVel, _rot: VectorVel)\n"
"TwistVel(p: Twist, v: Twist)\n"
"TwistVel(p: Twist)\n"
"TwistVel(TwistVel)");


sipClassTypeDef sipTypeDef_PyKDL_TwistVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_TwistVel,
        {0},
        0
    },
    {
        sipNameNr_TwistVel,
        {0, 0, 1},
        7, methods_TwistVel,
        0, 0,
        2, variables_TwistVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_TwistVel,
    -1,
    -1,
    0,
    slots_TwistVel,
    init_type_TwistVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_TwistVel,
    assign_TwistVel,
    array_TwistVel,
    copy_TwistVel,
    release_TwistVel,
    0,
    0,
    0,
    0,
    pickle_TwistVel,
    0,
    0
};

#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4018 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 100 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4023 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4027 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4033 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4039 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4045 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 207 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4049 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_FrameVel_value, "value(self) -> Frame");

extern "C" {static PyObject *meth_FrameVel_value(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_value, doc_FrameVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_deriv, "deriv(self) -> Twist");

extern "C" {static PyObject *meth_FrameVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_deriv, doc_FrameVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Identity, "Identity() -> FrameVel");

extern "C" {static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel( ::FrameVel::Identity());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Identity, doc_FrameVel_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Inverse, "Inverse(self) -> FrameVel\n"
"Inverse(self, arg: VectorVel) -> VectorVel\n"
"Inverse(self, arg: Vector) -> VectorVel\n"
"Inverse(self, arg: TwistVel) -> TwistVel\n"
"Inverse(self, arg: Twist) -> TwistVel");

extern "C" {static PyObject *meth_FrameVel_Inverse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Inverse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_VectorVel, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Vector, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_TwistVel, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Twist, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Inverse, doc_FrameVel_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetFrame, "GetFrame(self) -> Frame");

extern "C" {static PyObject *meth_FrameVel_GetFrame(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetFrame(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->GetFrame());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetFrame, doc_FrameVel_GetFrame);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetTwist, "GetTwist(self) -> Twist");

extern "C" {static PyObject *meth_FrameVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetTwist, doc_FrameVel_GetTwist);

    return NULL;
}


extern "C" {static PyObject *slot_FrameVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_FrameVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::FrameVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Twist, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_FrameVel, &a1))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::Frame* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Frame, &a1))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_FrameVel(void *, int);}
static void release_FrameVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::FrameVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_FrameVel(void *);}
static PyObject *pickle_FrameVel(void *sipCppV)
{
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipCppV);
    PyObject *sipRes;

#line 191 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    const sipTypeDef *rotationvel_type = sipFindType("RotationVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->M), rotationvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->p), vectorvel_type, Py_None));
#line 4415 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_FrameVel(void *, SIP_SSIZE_T, void *);}
static void assign_FrameVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::FrameVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::FrameVel *>(sipSrc);
}


extern "C" {static void *array_FrameVel(SIP_SSIZE_T);}
static void *array_FrameVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::FrameVel[sipNrElem];
}


extern "C" {static void *copy_FrameVel(const void *, SIP_SSIZE_T);}
static void *copy_FrameVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::FrameVel(reinterpret_cast<const  ::FrameVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_FrameVel(sipSimpleWrapper *);}
static void dealloc_FrameVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_FrameVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::FrameVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::FrameVel();

            return sipCpp;
        }
    }

    {
        const  ::Frame* a0;

        static const char *sipKwdList[] = {
            sipName__T,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Frame, &a0))
        {
            sipCpp = new  ::FrameVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::Frame* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName__T,
            sipName__t,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Frame, &a0, sipType_Twist, &a1))
        {
            sipCpp = new  ::FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName__M,
            sipName__p,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_RotationVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new  ::FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::FrameVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_FrameVel, &a0))
        {
            sipCpp = new  ::FrameVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_FrameVel[] = {
    {(void *)slot_FrameVel___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_FrameVel[] = {
    {SIP_MLNAME_CAST(sipName_GetFrame), meth_FrameVel_GetFrame, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetFrame)},
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_FrameVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_FrameVel_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_Identity)},
    {SIP_MLNAME_CAST(sipName_Inverse), (PyCFunction)meth_FrameVel_Inverse, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_FrameVel_Inverse)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_FrameVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_FrameVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_value)}
};


extern "C" {static PyObject *varget_FrameVel_M(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_M(void *sipSelf, PyObject *, PyObject *)
{
     ::RotationVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    sipVal = &sipCpp->M;

    return sipConvertFromType(sipVal, sipType_RotationVel, NULL);
}


extern "C" {static int varset_FrameVel_M(void *, PyObject *, PyObject *);}
static int varset_FrameVel_M(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::RotationVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::RotationVel *>(sipForceConvertToType(sipPy,sipType_RotationVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->M = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_FrameVel_p(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_p(void *sipSelf, PyObject *, PyObject *)
{
     ::VectorVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    sipVal = &sipCpp->p;

    return sipConvertFromType(sipVal, sipType_VectorVel, NULL);
}


extern "C" {static int varset_FrameVel_p(void *, PyObject *, PyObject *);}
static int varset_FrameVel_p(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->p = *sipVal;

    return 0;
}

sipVariableDef variables_FrameVel[] = {
    {InstanceVariable, sipName_M, (PyMethodDef *)varget_FrameVel_M, (PyMethodDef *)varset_FrameVel_M, NULL, NULL},
    {InstanceVariable, sipName_p, (PyMethodDef *)varget_FrameVel_p, (PyMethodDef *)varset_FrameVel_p, NULL, NULL},
};

PyDoc_STRVAR(doc_FrameVel, "\1FrameVel()\n"
"FrameVel(_T: Frame)\n"
"FrameVel(_T: Frame, _t: Twist)\n"
"FrameVel(_M: RotationVel, _p: VectorVel)\n"
"FrameVel(FrameVel)");


sipClassTypeDef sipTypeDef_PyKDL_FrameVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_FrameVel,
        {0},
        0
    },
    {
        sipNameNr_FrameVel,
        {0, 0, 1},
        6, methods_FrameVel,
        0, 0,
        2, variables_FrameVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_FrameVel,
    -1,
    -1,
    0,
    slots_FrameVel,
    init_type_FrameVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_FrameVel,
    assign_FrameVel,
    array_FrameVel,
    copy_FrameVel,
    release_FrameVel,
    0,
    0,
    0,
    0,
    pickle_FrameVel,
    0,
    0
};

#line 100 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4677 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 102 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4684 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4690 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4694 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4698 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 207 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4702 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4708 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_RotationVel_value, "value(self) -> Rotation");

extern "C" {static PyObject *meth_RotationVel_value(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_value, doc_RotationVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_deriv, "deriv(self) -> Vector");

extern "C" {static PyObject *meth_RotationVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_deriv, doc_RotationVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_UnitX, "UnitX(self) -> VectorVel");

extern "C" {static PyObject *meth_RotationVel_UnitX(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_UnitX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->UnitX());

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_UnitX, doc_RotationVel_UnitX);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_UnitY, "UnitY(self) -> VectorVel");

extern "C" {static PyObject *meth_RotationVel_UnitY(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_UnitY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->UnitY());

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_UnitY, doc_RotationVel_UnitY);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_UnitZ, "UnitZ(self) -> VectorVel");

extern "C" {static PyObject *meth_RotationVel_UnitZ(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_UnitZ(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->UnitZ());

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_UnitZ, doc_RotationVel_UnitZ);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_Identity, "Identity() -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_Identity(PyObject *, PyObject *);}
static PyObject *meth_RotationVel_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::Identity());

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_Identity, doc_RotationVel_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_Inverse, "Inverse(self) -> RotationVel\n"
"Inverse(self, arg: VectorVel) -> VectorVel\n"
"Inverse(self, arg: Vector) -> VectorVel\n"
"Inverse(self, arg: TwistVel) -> TwistVel\n"
"Inverse(self, arg: Twist) -> TwistVel");

extern "C" {static PyObject *meth_RotationVel_Inverse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_Inverse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationVel *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_RotationVel, &sipCpp))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_VectorVel, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_Vector, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_TwistVel, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_Twist, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_Inverse, doc_RotationVel_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_DoRotX, "DoRotX(self, angle: doubleVel)");

extern "C" {static PyObject *meth_RotationVel_DoRotX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_DoRotX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;
         ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_doubleVel, &a0))
        {
            sipCpp->DoRotX(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_DoRotX, doc_RotationVel_DoRotX);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_DoRotY, "DoRotY(self, angle: doubleVel)");

extern "C" {static PyObject *meth_RotationVel_DoRotY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_DoRotY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;
         ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_doubleVel, &a0))
        {
            sipCpp->DoRotY(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_DoRotY, doc_RotationVel_DoRotY);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_DoRotZ, "DoRotZ(self, angle: doubleVel)");

extern "C" {static PyObject *meth_RotationVel_DoRotZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_DoRotZ(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;
         ::RotationVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RotationVel, &sipCpp, sipType_doubleVel, &a0))
        {
            sipCpp->DoRotZ(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_DoRotZ, doc_RotationVel_DoRotZ);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_RotX, "RotX(angle: doubleVel) -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_RotX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_RotX(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_doubleVel, &a0))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::RotX(*a0));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_RotX, doc_RotationVel_RotX);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_RotY, "RotY(angle: doubleVel) -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_RotY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_RotY(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_doubleVel, &a0))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::RotY(*a0));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_RotY, doc_RotationVel_RotY);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_RotZ, "RotZ(angle: doubleVel) -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_RotZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_RotZ(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_doubleVel, &a0))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::RotZ(*a0));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_RotZ, doc_RotationVel_RotZ);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_Rot, "Rot(rotvec: Vector, angle: doubleVel) -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_Rot(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_Rot(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::doubleVel* a1;

        static const char *sipKwdList[] = {
            sipName_rotvec,
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_doubleVel, &a1))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::Rot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_Rot, doc_RotationVel_Rot);

    return NULL;
}


PyDoc_STRVAR(doc_RotationVel_Rot2, "Rot2(rotvec: Vector, angle: doubleVel) -> RotationVel");

extern "C" {static PyObject *meth_RotationVel_Rot2(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RotationVel_Rot2(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::doubleVel* a1;

        static const char *sipKwdList[] = {
            sipName_rotvec,
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_doubleVel, &a1))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel( ::RotationVel::Rot2(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationVel, sipName_Rot2, doc_RotationVel_Rot2);

    return NULL;
}


extern "C" {static PyObject *slot_RotationVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_RotationVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::RotationVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::RotationVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::RotationVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
         ::RotationVel* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_Twist, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::RotationVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_RotationVel, &a1))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::Rotation* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationVel, &a0, sipType_Rotation, &a1))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_RotationVel(void *, int);}
static void release_RotationVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::RotationVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_RotationVel(void *);}
static PyObject *pickle_RotationVel(void *sipCppV)
{
     ::RotationVel *sipCpp = reinterpret_cast< ::RotationVel *>(sipCppV);
    PyObject *sipRes;

#line 139 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vector_type = sipFindType("Vector");
    const sipTypeDef *rotation_type = sipFindType("Rotation");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->R), rotation_type, Py_None),
                                 sipConvertFromType(&(sipCpp->w), vector_type, Py_None));
#line 5362 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_RotationVel(void *, SIP_SSIZE_T, void *);}
static void assign_RotationVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RotationVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RotationVel *>(sipSrc);
}


extern "C" {static void *array_RotationVel(SIP_SSIZE_T);}
static void *array_RotationVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::RotationVel[sipNrElem];
}


extern "C" {static void *copy_RotationVel(const void *, SIP_SSIZE_T);}
static void *copy_RotationVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RotationVel(reinterpret_cast<const  ::RotationVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RotationVel(sipSimpleWrapper *);}
static void dealloc_RotationVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RotationVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RotationVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RotationVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RotationVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::RotationVel();

            return sipCpp;
        }
    }

    {
        const  ::Rotation* a0;

        static const char *sipKwdList[] = {
            sipName__R,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Rotation, &a0))
        {
            sipCpp = new  ::RotationVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName__R,
            sipName__w,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Rotation, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::RotationVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::RotationVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RotationVel, &a0))
        {
            sipCpp = new  ::RotationVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RotationVel[] = {
    {(void *)slot_RotationVel___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RotationVel[] = {
    {SIP_MLNAME_CAST(sipName_DoRotX), (PyCFunction)meth_RotationVel_DoRotX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_DoRotX)},
    {SIP_MLNAME_CAST(sipName_DoRotY), (PyCFunction)meth_RotationVel_DoRotY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_DoRotY)},
    {SIP_MLNAME_CAST(sipName_DoRotZ), (PyCFunction)meth_RotationVel_DoRotZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_DoRotZ)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_RotationVel_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_Identity)},
    {SIP_MLNAME_CAST(sipName_Inverse), (PyCFunction)meth_RotationVel_Inverse, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_Inverse)},
    {SIP_MLNAME_CAST(sipName_Rot), (PyCFunction)meth_RotationVel_Rot, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_Rot)},
    {SIP_MLNAME_CAST(sipName_Rot2), (PyCFunction)meth_RotationVel_Rot2, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_Rot2)},
    {SIP_MLNAME_CAST(sipName_RotX), (PyCFunction)meth_RotationVel_RotX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_RotX)},
    {SIP_MLNAME_CAST(sipName_RotY), (PyCFunction)meth_RotationVel_RotY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_RotY)},
    {SIP_MLNAME_CAST(sipName_RotZ), (PyCFunction)meth_RotationVel_RotZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RotationVel_RotZ)},
    {SIP_MLNAME_CAST(sipName_UnitX), meth_RotationVel_UnitX, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_UnitX)},
    {SIP_MLNAME_CAST(sipName_UnitY), meth_RotationVel_UnitY, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_UnitY)},
    {SIP_MLNAME_CAST(sipName_UnitZ), meth_RotationVel_UnitZ, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_UnitZ)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_RotationVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_RotationVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationVel_value)}
};


extern "C" {static PyObject *varget_RotationVel_R(void *, PyObject *, PyObject *);}
static PyObject *varget_RotationVel_R(void *sipSelf, PyObject *, PyObject *)
{
     ::Rotation*sipVal;
     ::RotationVel *sipCpp = reinterpret_cast< ::RotationVel *>(sipSelf);

    sipVal = &sipCpp->R;

    return sipConvertFromType(sipVal, sipType_Rotation, NULL);
}


extern "C" {static int varset_RotationVel_R(void *, PyObject *, PyObject *);}
static int varset_RotationVel_R(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Rotation*sipVal;
     ::RotationVel *sipCpp = reinterpret_cast< ::RotationVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Rotation *>(sipForceConvertToType(sipPy,sipType_Rotation,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->R = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_RotationVel_w(void *, PyObject *, PyObject *);}
static PyObject *varget_RotationVel_w(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::RotationVel *sipCpp = reinterpret_cast< ::RotationVel *>(sipSelf);

    sipVal = &sipCpp->w;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_RotationVel_w(void *, PyObject *, PyObject *);}
static int varset_RotationVel_w(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::RotationVel *sipCpp = reinterpret_cast< ::RotationVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->w = *sipVal;

    return 0;
}

sipVariableDef variables_RotationVel[] = {
    {InstanceVariable, sipName_R, (PyMethodDef *)varget_RotationVel_R, (PyMethodDef *)varset_RotationVel_R, NULL, NULL},
    {InstanceVariable, sipName_w, (PyMethodDef *)varget_RotationVel_w, (PyMethodDef *)varset_RotationVel_w, NULL, NULL},
};

PyDoc_STRVAR(doc_RotationVel, "\1RotationVel()\n"
"RotationVel(_R: Rotation)\n"
"RotationVel(_R: Rotation, _w: Vector)\n"
"RotationVel(RotationVel)");


sipClassTypeDef sipTypeDef_PyKDL_RotationVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RotationVel,
        {0},
        0
    },
    {
        sipNameNr_RotationVel,
        {0, 0, 1},
        15, methods_RotationVel,
        0, 0,
        2, variables_RotationVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RotationVel,
    -1,
    -1,
    0,
    slots_RotationVel,
    init_type_RotationVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RotationVel,
    assign_RotationVel,
    array_RotationVel,
    copy_RotationVel,
    release_RotationVel,
    0,
    0,
    0,
    0,
    pickle_RotationVel,
    0,
    0
};

#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 5614 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 5621 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 5625 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_VectorVel_value, "value(self) -> Vector");

extern "C" {static PyObject *meth_VectorVel_value(PyObject *, PyObject *);}
static PyObject *meth_VectorVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_VectorVel, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VectorVel, sipName_value, doc_VectorVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_VectorVel_deriv, "deriv(self) -> Vector");

extern "C" {static PyObject *meth_VectorVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_VectorVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_VectorVel, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VectorVel, sipName_deriv, doc_VectorVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_VectorVel_Zero, "Zero() -> VectorVel");

extern "C" {static PyObject *meth_VectorVel_Zero(PyObject *, PyObject *);}
static PyObject *meth_VectorVel_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel( ::VectorVel::Zero());

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VectorVel, sipName_Zero, doc_VectorVel_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_VectorVel_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_VectorVel_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_VectorVel_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::VectorVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_VectorVel, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VectorVel, sipName_ReverseSign, doc_VectorVel_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_VectorVel_Norm, "Norm(self) -> doubleVel");

extern "C" {static PyObject *meth_VectorVel_Norm(PyObject *, PyObject *);}
static PyObject *meth_VectorVel_Norm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_VectorVel, &sipCpp))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(sipCpp->Norm());

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VectorVel, sipName_Norm, doc_VectorVel_Norm);

    return NULL;
}


extern "C" {static PyObject *slot_VectorVel___neg__(PyObject *);}
static PyObject *slot_VectorVel___neg__(PyObject *sipSelf)
{
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_VectorVel));

    if (!sipCpp)
        return 0;


    {
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_VectorVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_VectorVel, &a0, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        double a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_doubleVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_VectorVel___div__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_VectorVel, &a0, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_doubleVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 / *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_VectorVel___add__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_VectorVel___sub__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_VectorVel___isub__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_VectorVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_VectorVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_VectorVel, &a0))
        {
            sipCpp-> ::VectorVel::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_VectorVel___iadd__(PyObject *,PyObject *);}
static PyObject *slot_VectorVel___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_VectorVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_VectorVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_VectorVel, &a0))
        {
            sipCpp-> ::VectorVel::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_VectorVel(void *, int);}
static void release_VectorVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::VectorVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_VectorVel(void *);}
static PyObject *pickle_VectorVel(void *sipCppV)
{
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipCppV);
    PyObject *sipRes;

#line 64 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vector_type = sipFindType("Vector");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->p), vector_type, Py_None),
                                 sipConvertFromType(&(sipCpp->v), vector_type, Py_None));
#line 6096 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_VectorVel(void *, SIP_SSIZE_T, void *);}
static void assign_VectorVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::VectorVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::VectorVel *>(sipSrc);
}


extern "C" {static void *array_VectorVel(SIP_SSIZE_T);}
static void *array_VectorVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::VectorVel[sipNrElem];
}


extern "C" {static void *copy_VectorVel(const void *, SIP_SSIZE_T);}
static void *copy_VectorVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::VectorVel(reinterpret_cast<const  ::VectorVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_VectorVel(sipSimpleWrapper *);}
static void dealloc_VectorVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_VectorVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_VectorVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_VectorVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::VectorVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::VectorVel();

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName__p,
            sipName__v,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::VectorVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;

        static const char *sipKwdList[] = {
            sipName__p,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Vector, &a0))
        {
            sipCpp = new  ::VectorVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::VectorVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_VectorVel, &a0))
        {
            sipCpp = new  ::VectorVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_VectorVel[] = {
    {(void *)slot_VectorVel___neg__, neg_slot},
    {(void *)slot_VectorVel___mul__, mul_slot},
    {(void *)slot_VectorVel___div__, div_slot},
    {(void *)slot_VectorVel___add__, add_slot},
    {(void *)slot_VectorVel___sub__, sub_slot},
    {(void *)slot_VectorVel___isub__, isub_slot},
    {(void *)slot_VectorVel___iadd__, iadd_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_VectorVel[] = {
    {SIP_MLNAME_CAST(sipName_Norm), meth_VectorVel_Norm, METH_VARARGS, SIP_MLDOC_CAST(doc_VectorVel_Norm)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_VectorVel_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_VectorVel_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_VectorVel_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_VectorVel_Zero)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_VectorVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_VectorVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_VectorVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_VectorVel_value)}
};


extern "C" {static PyObject *varget_VectorVel_p(void *, PyObject *, PyObject *);}
static PyObject *varget_VectorVel_p(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipSelf);

    sipVal = &sipCpp->p;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_VectorVel_p(void *, PyObject *, PyObject *);}
static int varset_VectorVel_p(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->p = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_VectorVel_v(void *, PyObject *, PyObject *);}
static PyObject *varget_VectorVel_v(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipSelf);

    sipVal = &sipCpp->v;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_VectorVel_v(void *, PyObject *, PyObject *);}
static int varset_VectorVel_v(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::VectorVel *sipCpp = reinterpret_cast< ::VectorVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->v = *sipVal;

    return 0;
}

sipVariableDef variables_VectorVel[] = {
    {InstanceVariable, sipName_p, (PyMethodDef *)varget_VectorVel_p, (PyMethodDef *)varset_VectorVel_p, NULL, NULL},
    {InstanceVariable, sipName_v, (PyMethodDef *)varget_VectorVel_v, (PyMethodDef *)varset_VectorVel_v, NULL, NULL},
};

PyDoc_STRVAR(doc_VectorVel, "\1VectorVel()\n"
"VectorVel(_p: Vector, _v: Vector)\n"
"VectorVel(_p: Vector)\n"
"VectorVel(VectorVel)");


sipClassTypeDef sipTypeDef_PyKDL_VectorVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_VectorVel,
        {0},
        0
    },
    {
        sipNameNr_VectorVel,
        {0, 0, 1},
        5, methods_VectorVel,
        0, 0,
        2, variables_VectorVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_VectorVel,
    -1,
    -1,
    0,
    slots_VectorVel,
    init_type_VectorVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_VectorVel,
    assign_VectorVel,
    array_VectorVel,
    copy_VectorVel,
    release_VectorVel,
    0,
    0,
    0,
    0,
    pickle_VectorVel,
    0,
    0
};

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 6344 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 6349 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 207 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 6353 "sip_PyKDL/sipPyKDLpart0.cpp"


extern "C" {static PyObject *slot_doubleVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_doubleVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::doubleVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_doubleVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_doubleVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_doubleVel(void *, int);}
static void release_doubleVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::doubleVel *>(sipCppV);
}


extern "C" {static void assign_doubleVel(void *, SIP_SSIZE_T, void *);}
static void assign_doubleVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::doubleVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::doubleVel *>(sipSrc);
}


extern "C" {static void *array_doubleVel(SIP_SSIZE_T);}
static void *array_doubleVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::doubleVel[sipNrElem];
}


extern "C" {static void *copy_doubleVel(const void *, SIP_SSIZE_T);}
static void *copy_doubleVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::doubleVel(reinterpret_cast<const  ::doubleVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_doubleVel(sipSimpleWrapper *);}
static void dealloc_doubleVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_doubleVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_doubleVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_doubleVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::doubleVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::doubleVel();

            return sipCpp;
        }
    }

    {
        const  ::doubleVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_doubleVel, &a0))
        {
            sipCpp = new  ::doubleVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_doubleVel[] = {
    {(void *)slot_doubleVel___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


extern "C" {static PyObject *varget_doubleVel_grad(void *, PyObject *, PyObject *);}
static PyObject *varget_doubleVel_grad(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::doubleVel *sipCpp = reinterpret_cast< ::doubleVel *>(sipSelf);

    sipVal = sipCpp->grad;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_doubleVel_grad(void *, PyObject *, PyObject *);}
static int varset_doubleVel_grad(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::doubleVel *sipCpp = reinterpret_cast< ::doubleVel *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->grad = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_doubleVel_t(void *, PyObject *, PyObject *);}
static PyObject *varget_doubleVel_t(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::doubleVel *sipCpp = reinterpret_cast< ::doubleVel *>(sipSelf);

    sipVal = sipCpp->t;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_doubleVel_t(void *, PyObject *, PyObject *);}
static int varset_doubleVel_t(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::doubleVel *sipCpp = reinterpret_cast< ::doubleVel *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->t = sipVal;

    return 0;
}

sipVariableDef variables_doubleVel[] = {
    {InstanceVariable, sipName_grad, (PyMethodDef *)varget_doubleVel_grad, (PyMethodDef *)varset_doubleVel_grad, NULL, NULL},
    {InstanceVariable, sipName_t, (PyMethodDef *)varget_doubleVel_t, (PyMethodDef *)varset_doubleVel_t, NULL, NULL},
};

PyDoc_STRVAR(doc_doubleVel, "\1doubleVel()\n"
"doubleVel(doubleVel)");


sipClassTypeDef sipTypeDef_PyKDL_doubleVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_doubleVel,
        {0},
        0
    },
    {
        sipNameNr_doubleVel,
        {0, 0, 1},
        0, 0,
        0, 0,
        2, variables_doubleVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_doubleVel,
    -1,
    -1,
    0,
    slots_doubleVel,
    init_type_doubleVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_doubleVel,
    assign_doubleVel,
    array_doubleVel,
    copy_doubleVel,
    release_doubleVel,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 705 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainidsolver_recursive_newton_euler.hpp>
using namespace KDL;
#line 6593 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 6598 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 6604 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 6608 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 27 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 6611 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 6617 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIdSolver_RNE : public  ::ChainIdSolver_RNE
{
public:
    sipChainIdSolver_RNE(const  ::Chain&, ::Vector);
    sipChainIdSolver_RNE(const  ::ChainIdSolver_RNE&);
    virtual ~sipChainIdSolver_RNE();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::JntArray&,const  ::JntArray&,const std::vector< ::Wrench>&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIdSolver_RNE(const sipChainIdSolver_RNE &);
    sipChainIdSolver_RNE &operator = (const sipChainIdSolver_RNE &);

    char sipPyMethods[2];
};

sipChainIdSolver_RNE::sipChainIdSolver_RNE(const  ::Chain& a0, ::Vector a1):  ::ChainIdSolver_RNE(a0,a1), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIdSolver_RNE::sipChainIdSolver_RNE(const  ::ChainIdSolver_RNE& a0):  ::ChainIdSolver_RNE(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIdSolver_RNE::~sipChainIdSolver_RNE()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIdSolver_RNE::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIdSolver_RNE::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIdSolver_RNE::CartToJnt(const  ::JntArray& a0,const  ::JntArray& a1,const  ::JntArray& a2,const std::vector< ::Wrench>& a3, ::JntArray& a4)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIdSolver_RNE::CartToJnt(a0,a1,a2,a3,a4);

    extern int sipVH_PyKDL_10(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::JntArray&,const  ::JntArray&,const std::vector< ::Wrench>&, ::JntArray&);

    return sipVH_PyKDL_10(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2, a3, a4);
}


PyDoc_STRVAR(doc_ChainIdSolver_RNE_CartToJnt, "CartToJnt(self, q: JntArray, q_dot: JntArray, q_dotdot: JntArray, f_ext: object, torques: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIdSolver_RNE_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIdSolver_RNE_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
        const  ::JntArray* a2;
        const std::vector< ::Wrench>* a3;
        int a3State = 0;
         ::JntArray* a4;
         ::ChainIdSolver_RNE *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_q_dot,
            sipName_q_dotdot,
            sipName_f_ext,
            sipName_torques,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9J1J9", &sipSelf, sipType_ChainIdSolver_RNE, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2, sipType_std_vector_0100Wrench,&a3, &a3State, sipType_JntArray, &a4))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIdSolver_RNE::CartToJnt(*a0,*a1,*a2,*a3,*a4) : sipCpp->CartToJnt(*a0,*a1,*a2,*a3,*a4));
            sipReleaseType(const_cast<std::vector< ::Wrench> *>(a3),sipType_std_vector_0100Wrench,a3State);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIdSolver_RNE, sipName_CartToJnt, doc_ChainIdSolver_RNE_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIdSolver_RNE_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIdSolver_RNE_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIdSolver_RNE_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIdSolver_RNE *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIdSolver_RNE, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIdSolver_RNE::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIdSolver_RNE, sipName_updateInternalDataStructures, doc_ChainIdSolver_RNE_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIdSolver_RNE(void *, const sipTypeDef *);}
static void *cast_ChainIdSolver_RNE(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIdSolver_RNE *sipCpp = reinterpret_cast< ::ChainIdSolver_RNE *>(sipCppV);

    if (targetType == sipType_ChainIdSolver)
        return static_cast< ::ChainIdSolver *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIdSolver_RNE(void *, int);}
static void release_ChainIdSolver_RNE(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIdSolver_RNE *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIdSolver_RNE *>(sipCppV);
}


extern "C" {static void dealloc_ChainIdSolver_RNE(sipSimpleWrapper *);}
static void dealloc_ChainIdSolver_RNE(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIdSolver_RNE *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIdSolver_RNE(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIdSolver_RNE(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIdSolver_RNE(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIdSolver_RNE *sipCpp = 0;

    {
        const  ::Chain* a0;
         ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_grav,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Chain, &a0, sipType_Vector, &a1))
        {
            sipCpp = new sipChainIdSolver_RNE(*a0,*a1);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIdSolver_RNE* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIdSolver_RNE, &a0))
        {
            sipCpp = new sipChainIdSolver_RNE(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIdSolver_RNE[] = {{6, 255, 1}};


static PyMethodDef methods_ChainIdSolver_RNE[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIdSolver_RNE_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIdSolver_RNE_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIdSolver_RNE_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIdSolver_RNE_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIdSolver_RNE, "\1ChainIdSolver_RNE(chain: Chain, grav: Vector)\n"
"ChainIdSolver_RNE(ChainIdSolver_RNE)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIdSolver_RNE = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIdSolver_RNE,
        {0},
        0
    },
    {
        sipNameNr_ChainIdSolver_RNE,
        {0, 0, 1},
        2, methods_ChainIdSolver_RNE,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIdSolver_RNE,
    -1,
    -1,
    supers_ChainIdSolver_RNE,
    0,
    init_type_ChainIdSolver_RNE,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIdSolver_RNE,
    0,
    0,
    0,
    release_ChainIdSolver_RNE,
    cast_ChainIdSolver_RNE,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 696 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainidsolver.hpp>
using namespace KDL;
#line 6914 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 6919 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 27 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 6922 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 6928 "sip_PyKDL/sipPyKDLpart0.cpp"


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIdSolver(void *, const sipTypeDef *);}
static void *cast_ChainIdSolver(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIdSolver *sipCpp = reinterpret_cast< ::ChainIdSolver *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIdSolver(void *, int);}
static void release_ChainIdSolver(void *sipCppV, int)
{
    delete reinterpret_cast< ::ChainIdSolver *>(sipCppV);
}


extern "C" {static void dealloc_ChainIdSolver(sipSimpleWrapper *);}
static void dealloc_ChainIdSolver(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIdSolver(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIdSolver[] = {{32, 255, 1}};


sipClassTypeDef sipTypeDef_PyKDL_ChainIdSolver = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainIdSolver,
        {0},
        0
    },
    {
        sipNameNr_ChainIdSolver,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    supers_ChainIdSolver,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIdSolver,
    0,
    0,
    0,
    release_ChainIdSolver,
    cast_ChainIdSolver,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 684 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainjnttojacdotsolver.hpp>
using namespace KDL;
#line 7018 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 7023 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 7027 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 358 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 7031 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainJntToJacDotSolver : public  ::ChainJntToJacDotSolver
{
public:
    sipChainJntToJacDotSolver(const  ::Chain&);
    sipChainJntToJacDotSolver(const  ::ChainJntToJacDotSolver&);
    virtual ~sipChainJntToJacDotSolver();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainJntToJacDotSolver(const sipChainJntToJacDotSolver &);
    sipChainJntToJacDotSolver &operator = (const sipChainJntToJacDotSolver &);

    char sipPyMethods[1];
};

sipChainJntToJacDotSolver::sipChainJntToJacDotSolver(const  ::Chain& a0):  ::ChainJntToJacDotSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacDotSolver::sipChainJntToJacDotSolver(const  ::ChainJntToJacDotSolver& a0):  ::ChainJntToJacDotSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacDotSolver::~sipChainJntToJacDotSolver()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainJntToJacDotSolver::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainJntToJacDotSolver::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainJntToJacDotSolver_JntToJacDot, "JntToJacDot(self, q_in: JntArrayVel, jac: Jacobian, seg_nr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainJntToJacDotSolver_JntToJacDot(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacDotSolver_JntToJacDot(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArrayVel* a0;
         ::Jacobian* a1;
        int a2 = -1;
         ::ChainJntToJacDotSolver *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_jac,
            sipName_seg_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9|i", &sipSelf, sipType_ChainJntToJacDotSolver, &sipCpp, sipType_JntArrayVel, &a0, sipType_Jacobian, &a1, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToJacDot(*a0,*a1,a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacDotSolver, sipName_JntToJacDot, doc_ChainJntToJacDotSolver_JntToJacDot);

    return NULL;
}


PyDoc_STRVAR(doc_ChainJntToJacDotSolver_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainJntToJacDotSolver_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacDotSolver_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainJntToJacDotSolver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainJntToJacDotSolver, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainJntToJacDotSolver::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacDotSolver, sipName_updateInternalDataStructures, doc_ChainJntToJacDotSolver_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainJntToJacDotSolver(void *, const sipTypeDef *);}
static void *cast_ChainJntToJacDotSolver(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainJntToJacDotSolver *sipCpp = reinterpret_cast< ::ChainJntToJacDotSolver *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainJntToJacDotSolver(void *, int);}
static void release_ChainJntToJacDotSolver(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainJntToJacDotSolver *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainJntToJacDotSolver *>(sipCppV);
}


extern "C" {static void dealloc_ChainJntToJacDotSolver(sipSimpleWrapper *);}
static void dealloc_ChainJntToJacDotSolver(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainJntToJacDotSolver *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainJntToJacDotSolver(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainJntToJacDotSolver(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainJntToJacDotSolver(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainJntToJacDotSolver *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainJntToJacDotSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainJntToJacDotSolver* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainJntToJacDotSolver, &a0))
        {
            sipCpp = new sipChainJntToJacDotSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainJntToJacDotSolver[] = {{32, 255, 1}};


static PyMethodDef methods_ChainJntToJacDotSolver[] = {
    {SIP_MLNAME_CAST(sipName_JntToJacDot), (PyCFunction)meth_ChainJntToJacDotSolver_JntToJacDot, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainJntToJacDotSolver_JntToJacDot)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainJntToJacDotSolver_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainJntToJacDotSolver_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainJntToJacDotSolver, "\1ChainJntToJacDotSolver(chain: Chain)\n"
"ChainJntToJacDotSolver(ChainJntToJacDotSolver)");


sipClassTypeDef sipTypeDef_PyKDL_ChainJntToJacDotSolver = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainJntToJacDotSolver,
        {0},
        0
    },
    {
        sipNameNr_ChainJntToJacDotSolver,
        {0, 0, 1},
        2, methods_ChainJntToJacDotSolver,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainJntToJacDotSolver,
    -1,
    -1,
    supers_ChainJntToJacDotSolver,
    0,
    init_type_ChainJntToJacDotSolver,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainJntToJacDotSolver,
    0,
    0,
    0,
    release_ChainJntToJacDotSolver,
    cast_ChainJntToJacDotSolver,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 672 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainjnttojacsolver.hpp>
using namespace KDL;
#line 7300 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 7305 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 7309 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 358 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 7313 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainJntToJacSolver : public  ::ChainJntToJacSolver
{
public:
    sipChainJntToJacSolver(const  ::Chain&);
    sipChainJntToJacSolver(const  ::ChainJntToJacSolver&);
    virtual ~sipChainJntToJacSolver();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainJntToJacSolver(const sipChainJntToJacSolver &);
    sipChainJntToJacSolver &operator = (const sipChainJntToJacSolver &);

    char sipPyMethods[1];
};

sipChainJntToJacSolver::sipChainJntToJacSolver(const  ::Chain& a0):  ::ChainJntToJacSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacSolver::sipChainJntToJacSolver(const  ::ChainJntToJacSolver& a0):  ::ChainJntToJacSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacSolver::~sipChainJntToJacSolver()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainJntToJacSolver::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainJntToJacSolver::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainJntToJacSolver_JntToJac, "JntToJac(self, q_in: JntArray, jac: Jacobian, seg_nr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainJntToJacSolver_JntToJac(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacSolver_JntToJac(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::Jacobian* a1;
        int a2 = -1;
         ::ChainJntToJacSolver *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_jac,
            sipName_seg_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9|i", &sipSelf, sipType_ChainJntToJacSolver, &sipCpp, sipType_JntArray, &a0, sipType_Jacobian, &a1, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToJac(*a0,*a1,a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacSolver, sipName_JntToJac, doc_ChainJntToJacSolver_JntToJac);

    return NULL;
}


PyDoc_STRVAR(doc_ChainJntToJacSolver_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainJntToJacSolver_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacSolver_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainJntToJacSolver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainJntToJacSolver, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainJntToJacSolver::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacSolver, sipName_updateInternalDataStructures, doc_ChainJntToJacSolver_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainJntToJacSolver(void *, const sipTypeDef *);}
static void *cast_ChainJntToJacSolver(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainJntToJacSolver *sipCpp = reinterpret_cast< ::ChainJntToJacSolver *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainJntToJacSolver(void *, int);}
static void release_ChainJntToJacSolver(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainJntToJacSolver *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainJntToJacSolver *>(sipCppV);
}


extern "C" {static void dealloc_ChainJntToJacSolver(sipSimpleWrapper *);}
static void dealloc_ChainJntToJacSolver(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainJntToJacSolver *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainJntToJacSolver(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainJntToJacSolver(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainJntToJacSolver(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainJntToJacSolver *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainJntToJacSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainJntToJacSolver* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainJntToJacSolver, &a0))
        {
            sipCpp = new sipChainJntToJacSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainJntToJacSolver[] = {{32, 255, 1}};


static PyMethodDef methods_ChainJntToJacSolver[] = {
    {SIP_MLNAME_CAST(sipName_JntToJac), (PyCFunction)meth_ChainJntToJacSolver_JntToJac, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainJntToJacSolver_JntToJac)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainJntToJacSolver_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainJntToJacSolver_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainJntToJacSolver, "\1ChainJntToJacSolver(chain: Chain)\n"
"ChainJntToJacSolver(ChainJntToJacSolver)");


sipClassTypeDef sipTypeDef_PyKDL_ChainJntToJacSolver = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainJntToJacSolver,
        {0},
        0
    },
    {
        sipNameNr_ChainJntToJacSolver,
        {0, 0, 1},
        2, methods_ChainJntToJacSolver,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainJntToJacSolver,
    -1,
    -1,
    supers_ChainJntToJacSolver,
    0,
    init_type_ChainJntToJacSolver,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainJntToJacSolver,
    0,
    0,
    0,
    release_ChainJntToJacSolver,
    cast_ChainJntToJacSolver,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 659 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_givens.hpp>
using namespace KDL;
#line 7582 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 7587 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 7591 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 7597 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverVel_pinv_givens : public  ::ChainIkSolverVel_pinv_givens
{
public:
    sipChainIkSolverVel_pinv_givens(const  ::Chain&);
    sipChainIkSolverVel_pinv_givens(const  ::ChainIkSolverVel_pinv_givens&);
    virtual ~sipChainIkSolverVel_pinv_givens();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_givens(const sipChainIkSolverVel_pinv_givens &);
    sipChainIkSolverVel_pinv_givens &operator = (const sipChainIkSolverVel_pinv_givens &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv_givens::sipChainIkSolverVel_pinv_givens(const  ::Chain& a0):  ::ChainIkSolverVel_pinv_givens(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_givens::sipChainIkSolverVel_pinv_givens(const  ::ChainIkSolverVel_pinv_givens& a0):  ::ChainIkSolverVel_pinv_givens(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_givens::~sipChainIkSolverVel_pinv_givens()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_pinv_givens::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv_givens::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_givens::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_givens::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_givens_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_givens_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv_givens *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_givens, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_givens::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_givens, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_givens_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv_givens *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_givens, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_givens::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_givens, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_givens(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_givens(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv_givens *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv_givens *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_givens(void *, int);}
static void release_ChainIkSolverVel_pinv_givens(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_givens *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv_givens *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_givens *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv_givens(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_givens *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_givens(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv_givens* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_givens, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_givens(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_givens[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_givens[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_givens_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_givens_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens, "\1ChainIkSolverVel_pinv_givens(chain: Chain)\n"
"ChainIkSolverVel_pinv_givens(ChainIkSolverVel_pinv_givens)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_givens = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_givens,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_givens,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv_givens,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_givens,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_givens,
    0,
    init_type_ChainIkSolverVel_pinv_givens,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_givens,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_givens,
    cast_ChainIkSolverVel_pinv_givens,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 634 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_nso.hpp>
using namespace KDL;
#line 7886 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 7891 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 7895 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 7901 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverVel_pinv_nso : public  ::ChainIkSolverVel_pinv_nso
{
public:
    sipChainIkSolverVel_pinv_nso(const  ::Chain&,double,int,double);
    sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso&);
    virtual ~sipChainIkSolverVel_pinv_nso();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int setAlpha(const double);
    int setOptPos(const  ::JntArray&);
    int setWeights(const  ::JntArray&);
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_nso(const sipChainIkSolverVel_pinv_nso &);
    sipChainIkSolverVel_pinv_nso &operator = (const sipChainIkSolverVel_pinv_nso &);

    char sipPyMethods[5];
};

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverVel_pinv_nso(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso& a0):  ::ChainIkSolverVel_pinv_nso(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::~sipChainIkSolverVel_pinv_nso()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipChainIkSolverVel_pinv_nso::setAlpha(const double a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_setAlpha);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setAlpha(a0);

    extern int sipVH_PyKDL_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const double);

    return sipVH_PyKDL_9(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setOptPos(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_setOptPos);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setOptPos(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setWeights(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_setWeights);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setWeights(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipChainIkSolverVel_pinv_nso::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_nso::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_nso_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setWeights, "setWeights(self, weights: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_weights,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setWeights(*a0) : sipCpp->setWeights(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setWeights, doc_ChainIkSolverVel_pinv_nso_setWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setOptPos, "setOptPos(self, opt_pos: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_opt_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setOptPos(*a0) : sipCpp->setOptPos(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setOptPos, doc_ChainIkSolverVel_pinv_nso_setOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setAlpha, "setAlpha(self, alpha: float) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setAlpha(a0) : sipCpp->setAlpha(a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setAlpha, doc_ChainIkSolverVel_pinv_nso_setAlpha);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getWeights, "getWeights(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getWeights());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getWeights, doc_ChainIkSolverVel_pinv_nso_getWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getOptPos, "getOptPos(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getOptPos());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getOptPos, doc_ChainIkSolverVel_pinv_nso_getOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getAlpha, "getAlpha(self) -> float");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getAlpha();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getAlpha, doc_ChainIkSolverVel_pinv_nso_getAlpha);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_nso(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_nso(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv_nso *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_nso(void *, int);}
static void release_ChainIkSolverVel_pinv_nso(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv_nso(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_nso *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;
        double a3 = 0.25;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
            sipName_alpha,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv_nso* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_nso, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_nso[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_nso[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_getAlpha), meth_ChainIkSolverVel_pinv_nso_getAlpha, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getAlpha)},
    {SIP_MLNAME_CAST(sipName_getOptPos), meth_ChainIkSolverVel_pinv_nso_getOptPos, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getOptPos)},
    {SIP_MLNAME_CAST(sipName_getWeights), meth_ChainIkSolverVel_pinv_nso_getWeights, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getWeights)},
    {SIP_MLNAME_CAST(sipName_setAlpha), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setAlpha, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setAlpha)},
    {SIP_MLNAME_CAST(sipName_setOptPos), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setOptPos, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setOptPos)},
    {SIP_MLNAME_CAST(sipName_setWeights), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setWeights, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setWeights)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso, "\1ChainIkSolverVel_pinv_nso(chain: Chain, eps: float = 1e-05, maxiter: int = 150, alpha: float = 0.25)\n"
"ChainIkSolverVel_pinv_nso(ChainIkSolverVel_pinv_nso)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0, 0, 1},
        8, methods_ChainIkSolverVel_pinv_nso,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_nso,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_nso,
    0,
    init_type_ChainIkSolverVel_pinv_nso,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_nso,
    cast_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 620 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_lma.hpp>
using namespace KDL;
#line 8436 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 8441 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 8445 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 8451 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverPos_LMA : public  ::ChainIkSolverPos_LMA
{
public:
    sipChainIkSolverPos_LMA(const  ::Chain&,double,int,double);
    sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA&);
    virtual ~sipChainIkSolverPos_LMA();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_LMA(const sipChainIkSolverPos_LMA &);
    sipChainIkSolverPos_LMA &operator = (const sipChainIkSolverPos_LMA &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverPos_LMA(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA& a0):  ::ChainIkSolverPos_LMA(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::~sipChainIkSolverPos_LMA()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_LMA::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_LMA::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_LMA::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_LMA::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_LMA *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_CartToJnt, doc_ChainIkSolverPos_LMA_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_LMA *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_LMA_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_LMA(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_LMA(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_LMA *sipCpp = reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_LMA(void *, int);}
static void release_ChainIkSolverPos_LMA(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_LMA *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_LMA *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_LMA(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_LMA *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 500;
        double a3 = 1e-15;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName__maxiter,
            sipName__eps_joints,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_LMA* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_LMA, &a0))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_LMA[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_LMA[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_LMA_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_LMA_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_LMA, "\1ChainIkSolverPos_LMA(chain: Chain, eps: float = 1e-05, _maxiter: int = 500, _eps_joints: float = 1e-15)\n"
"ChainIkSolverPos_LMA(ChainIkSolverPos_LMA)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_LMA = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_LMA,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_LMA,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_LMA,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_LMA,
    -1,
    -1,
    supers_ChainIkSolverPos_LMA,
    0,
    init_type_ChainIkSolverPos_LMA,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    release_ChainIkSolverPos_LMA,
    cast_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 533 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_wdls.hpp>
using namespace KDL;
#line 8746 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 8751 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 8755 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 8761 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverVel_wdls : public  ::ChainIkSolverVel_wdls
{
public:
    sipChainIkSolverVel_wdls(const  ::Chain&,double,int);
    sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls&);
    virtual ~sipChainIkSolverVel_wdls();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_wdls(const sipChainIkSolverVel_wdls &);
    sipChainIkSolverVel_wdls &operator = (const sipChainIkSolverVel_wdls &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_wdls(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls& a0):  ::ChainIkSolverVel_wdls(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::~sipChainIkSolverVel_wdls()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_wdls::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_wdls::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_wdls::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_wdls::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_CartToJnt, doc_ChainIkSolverVel_wdls_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_wdls_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightTS, "setWeightTS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 544 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightTS(const Eigen::MatrixXd& Mx);
    //Mx has to be a 6x6 Matrix

    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    if (numRows!=6) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mx;
    Mx=Eigen::MatrixXd::Identity(numRows,numCols);
    
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mx(r,c)= c_item;
        }
    }
    sipCpp->setWeightTS(Mx);
#line 8954 "sip_PyKDL/sipPyKDLpart0.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightTS, doc_ChainIkSolverVel_wdls_setWeightTS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightJS, "setWeightJS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 581 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightJS(const Eigen::MatrixXd& Mx);
    //Mx has to be a simetric positive definite Matrix
    //unsigned int nOfJoints=sipCpp->chain.getNrOfJoints(); //To check that we are receiving valid data dimensions. This doesn't work, chain is a private member. todo: How can we check for this?
    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mq;
    Mq=Eigen::MatrixXd::Identity(numRows,numCols);
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mq(r,c)= c_item;
        }
    }
    sipCpp->setWeightJS(Mq);
#line 9017 "sip_PyKDL/sipPyKDLpart0.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightJS, doc_ChainIkSolverVel_wdls_setWeightJS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setLambda, "setLambda(self, lambda_: float)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lambda,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &a0))
        {
            sipCpp->setLambda(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setLambda, doc_ChainIkSolverVel_wdls_setLambda);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_wdls(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_wdls(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_wdls *sipCpp = reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_wdls(void *, int);}
static void release_ChainIkSolverVel_wdls(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_wdls *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_wdls *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_wdls(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_wdls *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_wdls* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_wdls, &a0))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_wdls[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_wdls[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_wdls_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_setLambda), (PyCFunction)meth_ChainIkSolverVel_wdls_setLambda, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setLambda)},
    {SIP_MLNAME_CAST(sipName_setWeightJS), meth_ChainIkSolverVel_wdls_setWeightJS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightJS)},
    {SIP_MLNAME_CAST(sipName_setWeightTS), meth_ChainIkSolverVel_wdls_setWeightTS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightTS)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_wdls_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_wdls, "\1ChainIkSolverVel_wdls(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_wdls(ChainIkSolverVel_wdls)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_wdls = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_wdls,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_wdls,
        {0, 0, 1},
        5, methods_ChainIkSolverVel_wdls,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_wdls,
    -1,
    -1,
    supers_ChainIkSolverVel_wdls,
    0,
    init_type_ChainIkSolverVel_wdls,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    release_ChainIkSolverVel_wdls,
    cast_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 520 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv.hpp>
using namespace KDL;
#line 9219 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 9224 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 9228 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 9234 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverVel_pinv : public  ::ChainIkSolverVel_pinv
{
public:
    sipChainIkSolverVel_pinv(const  ::Chain&,double,int);
    sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv&);
    virtual ~sipChainIkSolverVel_pinv();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv(const sipChainIkSolverVel_pinv &);
    sipChainIkSolverVel_pinv &operator = (const sipChainIkSolverVel_pinv &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_pinv(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv& a0):  ::ChainIkSolverVel_pinv(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::~sipChainIkSolverVel_pinv()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_pinv::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv(void *, int);}
static void release_ChainIkSolverVel_pinv(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv, "\1ChainIkSolverVel_pinv(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_pinv(ChainIkSolverVel_pinv)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv,
    0,
    init_type_ChainIkSolverVel_pinv,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv,
    cast_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 505 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr_jl.hpp>
using namespace KDL;
#line 9527 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 9532 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 9536 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 425 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 9540 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 479 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 9544 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 9550 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverPos_NR_JL : public  ::ChainIkSolverPos_NR_JL
{
public:
    sipChainIkSolverPos_NR_JL(const  ::Chain&,const  ::JntArray&,const  ::JntArray&, ::ChainFkSolverPos&, ::ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL&);
    virtual ~sipChainIkSolverPos_NR_JL();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR_JL(const sipChainIkSolverPos_NR_JL &);
    sipChainIkSolverPos_NR_JL &operator = (const sipChainIkSolverPos_NR_JL &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::Chain& a0,const  ::JntArray& a1,const  ::JntArray& a2, ::ChainFkSolverPos& a3, ::ChainIkSolverVel& a4,uint a5,double a6):  ::ChainIkSolverPos_NR_JL(a0,a1,a2,a3,a4,a5,a6), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL& a0):  ::ChainIkSolverPos_NR_JL(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::~sipChainIkSolverPos_NR_JL()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_NR_JL::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_NR_JL::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR_JL::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_NR_JL::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_NR_JL *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_CartToJnt, doc_ChainIkSolverPos_NR_JL_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_NR_JL *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR_JL(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR_JL(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_NR_JL *sipCpp = reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR_JL(void *, int);}
static void release_ChainIkSolverPos_NR_JL(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_NR_JL(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR_JL *sipCpp = 0;

    {
        const  ::Chain* a0;
        const  ::JntArray* a1;
        const  ::JntArray* a2;
         ::ChainFkSolverPos* a3;
         ::ChainIkSolverVel* a4;
        uint a5 = 100;
        double a6 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_q_min,
            sipName_q_max,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9J9J9|ud", sipType_Chain, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2, sipType_ChainFkSolverPos, &a3, sipType_ChainIkSolverVel, &a4, &a5, &a6))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0,*a1,*a2,*a3,*a4,a5,a6);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_NR_JL* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_NR_JL, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR_JL[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR_JL[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_NR_JL_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL, "\1ChainIkSolverPos_NR_JL(chain: Chain, q_min: JntArray, q_max: JntArray, fksolver: ChainFkSolverPos, iksolver: ChainIkSolverVel, maxiter: int = 100, eps: float = epsilon)\n"
"ChainIkSolverPos_NR_JL(ChainIkSolverPos_NR_JL)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR_JL,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_NR_JL,
    -1,
    -1,
    supers_ChainIkSolverPos_NR_JL,
    0,
    init_type_ChainIkSolverPos_NR_JL,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    release_ChainIkSolverPos_NR_JL,
    cast_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 491 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr.hpp>
using namespace KDL;
#line 9851 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 9856 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 425 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 9860 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 479 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 9864 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 9868 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 9874 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverPos_NR : public  ::ChainIkSolverPos_NR
{
public:
    sipChainIkSolverPos_NR(const  ::Chain&, ::ChainFkSolverPos&, ::ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR(const  ::ChainIkSolverPos_NR&);
    virtual ~sipChainIkSolverPos_NR();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR(const sipChainIkSolverPos_NR &);
    sipChainIkSolverPos_NR &operator = (const sipChainIkSolverPos_NR &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR::sipChainIkSolverPos_NR(const  ::Chain& a0, ::ChainFkSolverPos& a1, ::ChainIkSolverVel& a2,uint a3,double a4):  ::ChainIkSolverPos_NR(a0,a1,a2,a3,a4), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR::sipChainIkSolverPos_NR(const  ::ChainIkSolverPos_NR& a0):  ::ChainIkSolverPos_NR(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR::~sipChainIkSolverPos_NR()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_NR::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_NR::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_NR::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_NR *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR, sipName_CartToJnt, doc_ChainIkSolverPos_NR_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_NR *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_NR *sipCpp = reinterpret_cast< ::ChainIkSolverPos_NR *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR(void *, int);}
static void release_ChainIkSolverPos_NR(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_NR *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_NR(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR *sipCpp = 0;

    {
        const  ::Chain* a0;
         ::ChainFkSolverPos* a1;
         ::ChainIkSolverVel* a2;
        uint a3 = 100;
        double a4 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9|ud", sipType_Chain, &a0, sipType_ChainFkSolverPos, &a1, sipType_ChainIkSolverVel, &a2, &a3, &a4))
        {
            sipCpp = new sipChainIkSolverPos_NR(*a0,*a1,*a2,a3,a4);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_NR* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_NR, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_NR_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR, "\1ChainIkSolverPos_NR(chain: Chain, fksolver: ChainFkSolverPos, iksolver: ChainIkSolverVel, maxiter: int = 100, eps: float = epsilon)\n"
"ChainIkSolverPos_NR(ChainIkSolverPos_NR)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_NR,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_NR,
    -1,
    -1,
    supers_ChainIkSolverPos_NR,
    0,
    init_type_ChainIkSolverPos_NR,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_NR,
    0,
    0,
    0,
    release_ChainIkSolverPos_NR,
    cast_ChainIkSolverPos_NR,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 479 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 10171 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 10176 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 10182 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 10186 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 10190 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverVel : public  ::ChainIkSolverVel
{
public:
    sipChainIkSolverVel();
    sipChainIkSolverVel(const  ::ChainIkSolverVel&);
    virtual ~sipChainIkSolverVel();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int CartToJnt(const  ::JntArray&,const  ::FrameVel&, ::JntArrayVel&);
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);
    void updateInternalDataStructures();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel(const sipChainIkSolverVel &);
    sipChainIkSolverVel &operator = (const sipChainIkSolverVel &);

    char sipPyMethods[3];
};

sipChainIkSolverVel::sipChainIkSolverVel():  ::ChainIkSolverVel(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel::sipChainIkSolverVel(const  ::ChainIkSolverVel& a0):  ::ChainIkSolverVel(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel::~sipChainIkSolverVel()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipChainIkSolverVel::CartToJnt(const  ::JntArray& a0,const  ::FrameVel& a1, ::JntArrayVel& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_ChainIkSolverVel,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::FrameVel&, ::JntArrayVel&);

    return sipVH_PyKDL_7(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

int sipChainIkSolverVel::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,sipName_ChainIkSolverVel,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

void sipChainIkSolverVel::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,sipName_ChainIkSolverVel,sipName_updateInternalDataStructures);

    if (!sipMeth)
        return;

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int\n"
"CartToJnt(self, q_init: JntArray, v_in: FrameVel, q_out: JntArrayVel) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_CartToJnt);
                return NULL;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    {
        const  ::JntArray* a0;
        const  ::FrameVel* a1;
         ::JntArrayVel* a2;
         ::ChainIkSolverVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_v_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel, &sipCpp, sipType_JntArray, &a0, sipType_FrameVel, &a1, sipType_JntArrayVel, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_CartToJnt);
                return NULL;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel, sipName_CartToJnt, doc_ChainIkSolverVel_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::ChainIkSolverVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_updateInternalDataStructures);
                return NULL;
            }

            sipCpp->updateInternalDataStructures();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel *sipCpp = reinterpret_cast< ::ChainIkSolverVel *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel(void *, int);}
static void release_ChainIkSolverVel(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new sipChainIkSolverVel();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel, &a0))
        {
            sipCpp = new sipChainIkSolverVel(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel[] = {{32, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel, "\1ChainIkSolverVel()\n"
"ChainIkSolverVel(ChainIkSolverVel)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel,
        {0, 0, 1},
        2, methods_ChainIkSolverVel,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel,
    -1,
    -1,
    supers_ChainIkSolverVel,
    0,
    init_type_ChainIkSolverVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel,
    0,
    0,
    0,
    release_ChainIkSolverVel,
    cast_ChainIkSolverVel,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 469 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 10525 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 10530 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 10536 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainIkSolverPos : public  ::ChainIkSolverPos
{
public:
    sipChainIkSolverPos();
    sipChainIkSolverPos(const  ::ChainIkSolverPos&);
    virtual ~sipChainIkSolverPos();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);
    void updateInternalDataStructures();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos(const sipChainIkSolverPos &);
    sipChainIkSolverPos &operator = (const sipChainIkSolverPos &);

    char sipPyMethods[2];
};

sipChainIkSolverPos::sipChainIkSolverPos():  ::ChainIkSolverPos(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos::sipChainIkSolverPos(const  ::ChainIkSolverPos& a0):  ::ChainIkSolverPos(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos::~sipChainIkSolverPos()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipChainIkSolverPos::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_ChainIkSolverPos,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

void sipChainIkSolverPos::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,sipName_ChainIkSolverPos,sipName_updateInternalDataStructures);

    if (!sipMeth)
        return;

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverPos, sipName_CartToJnt);
                return NULL;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos, sipName_CartToJnt, doc_ChainIkSolverPos_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::ChainIkSolverPos *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverPos, sipName_updateInternalDataStructures);
                return NULL;
            }

            sipCpp->updateInternalDataStructures();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos *sipCpp = reinterpret_cast< ::ChainIkSolverPos *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos(void *, int);}
static void release_ChainIkSolverPos(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new sipChainIkSolverPos();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos, &a0))
        {
            sipCpp = new sipChainIkSolverPos(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos[] = {{32, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos, "\1ChainIkSolverPos()\n"
"ChainIkSolverPos(ChainIkSolverPos)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos,
        {0, 0, 1},
        2, methods_ChainIkSolverPos,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos,
    -1,
    -1,
    supers_ChainIkSolverPos,
    0,
    init_type_ChainIkSolverPos,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos,
    0,
    0,
    0,
    release_ChainIkSolverPos,
    cast_ChainIkSolverPos,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 457 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolvervel_recursive.hpp>
using namespace KDL;
#line 10825 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 10830 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 10834 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 10838 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainFkSolverVel_recursive : public  ::ChainFkSolverVel_recursive
{
public:
    sipChainFkSolverVel_recursive(const  ::Chain&);
    sipChainFkSolverVel_recursive(const  ::ChainFkSolverVel_recursive&);
    virtual ~sipChainFkSolverVel_recursive();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int JntToCart(const  ::JntArrayVel&, ::FrameVel&,int);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainFkSolverVel_recursive(const sipChainFkSolverVel_recursive &);
    sipChainFkSolverVel_recursive &operator = (const sipChainFkSolverVel_recursive &);

    char sipPyMethods[2];
};

sipChainFkSolverVel_recursive::sipChainFkSolverVel_recursive(const  ::Chain& a0):  ::ChainFkSolverVel_recursive(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverVel_recursive::sipChainFkSolverVel_recursive(const  ::ChainFkSolverVel_recursive& a0):  ::ChainFkSolverVel_recursive(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverVel_recursive::~sipChainFkSolverVel_recursive()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainFkSolverVel_recursive::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainFkSolverVel_recursive::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainFkSolverVel_recursive::JntToCart(const  ::JntArrayVel& a0, ::FrameVel& a1,int a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_JntToCart);

    if (!sipMeth)
        return  ::ChainFkSolverVel_recursive::JntToCart(a0,a1,a2);

    extern int sipVH_PyKDL_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArrayVel&, ::FrameVel&,int);

    return sipVH_PyKDL_4(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainFkSolverVel_recursive_JntToCart, "JntToCart(self, q_in: JntArrayVel, out: FrameVel, segmentNr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainFkSolverVel_recursive_JntToCart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverVel_recursive_JntToCart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArrayVel* a0;
         ::FrameVel* a1;
        int a2 = -1;
         ::ChainFkSolverVel_recursive *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_out,
            sipName_segmentNr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9|i", &sipSelf, sipType_ChainFkSolverVel_recursive, &sipCpp, sipType_JntArrayVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainFkSolverVel_recursive::JntToCart(*a0,*a1,a2) : sipCpp->JntToCart(*a0,*a1,a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverVel_recursive, sipName_JntToCart, doc_ChainFkSolverVel_recursive_JntToCart);

    return NULL;
}


PyDoc_STRVAR(doc_ChainFkSolverVel_recursive_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainFkSolverVel_recursive_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverVel_recursive_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainFkSolverVel_recursive *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainFkSolverVel_recursive, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainFkSolverVel_recursive::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverVel_recursive, sipName_updateInternalDataStructures, doc_ChainFkSolverVel_recursive_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverVel_recursive(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverVel_recursive(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverVel_recursive *sipCpp = reinterpret_cast< ::ChainFkSolverVel_recursive *>(sipCppV);

    if (targetType == sipType_ChainFkSolverVel)
        return static_cast< ::ChainFkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverVel_recursive(void *, int);}
static void release_ChainFkSolverVel_recursive(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainFkSolverVel_recursive *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainFkSolverVel_recursive *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverVel_recursive(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverVel_recursive(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainFkSolverVel_recursive *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverVel_recursive(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainFkSolverVel_recursive(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainFkSolverVel_recursive(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainFkSolverVel_recursive *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainFkSolverVel_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainFkSolverVel_recursive* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainFkSolverVel_recursive, &a0))
        {
            sipCpp = new sipChainFkSolverVel_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverVel_recursive[] = {{4, 255, 1}};


static PyMethodDef methods_ChainFkSolverVel_recursive[] = {
    {SIP_MLNAME_CAST(sipName_JntToCart), (PyCFunction)meth_ChainFkSolverVel_recursive_JntToCart, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainFkSolverVel_recursive_JntToCart)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainFkSolverVel_recursive_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainFkSolverVel_recursive_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainFkSolverVel_recursive, "\1ChainFkSolverVel_recursive(chain: Chain)\n"
"ChainFkSolverVel_recursive(ChainFkSolverVel_recursive)");


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverVel_recursive = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverVel_recursive,
        {0},
        0
    },
    {
        sipNameNr_ChainFkSolverVel_recursive,
        {0, 0, 1},
        2, methods_ChainFkSolverVel_recursive,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainFkSolverVel_recursive,
    -1,
    -1,
    supers_ChainFkSolverVel_recursive,
    0,
    init_type_ChainFkSolverVel_recursive,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainFkSolverVel_recursive,
    0,
    0,
    0,
    release_ChainFkSolverVel_recursive,
    cast_ChainFkSolverVel_recursive,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 444 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolverpos_recursive.hpp>
using namespace KDL;
#line 11127 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 11132 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 11136 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11142 "sip_PyKDL/sipPyKDLpart0.cpp"


class sipChainFkSolverPos_recursive : public  ::ChainFkSolverPos_recursive
{
public:
    sipChainFkSolverPos_recursive(const  ::Chain&);
    sipChainFkSolverPos_recursive(const  ::ChainFkSolverPos_recursive&);
    virtual ~sipChainFkSolverPos_recursive();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int JntToCart(const  ::JntArray&, ::Frame&,int);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainFkSolverPos_recursive(const sipChainFkSolverPos_recursive &);
    sipChainFkSolverPos_recursive &operator = (const sipChainFkSolverPos_recursive &);

    char sipPyMethods[2];
};

sipChainFkSolverPos_recursive::sipChainFkSolverPos_recursive(const  ::Chain& a0):  ::ChainFkSolverPos_recursive(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverPos_recursive::sipChainFkSolverPos_recursive(const  ::ChainFkSolverPos_recursive& a0):  ::ChainFkSolverPos_recursive(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverPos_recursive::~sipChainFkSolverPos_recursive()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainFkSolverPos_recursive::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainFkSolverPos_recursive::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainFkSolverPos_recursive::JntToCart(const  ::JntArray& a0, ::Frame& a1,int a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_JntToCart);

    if (!sipMeth)
        return  ::ChainFkSolverPos_recursive::JntToCart(a0,a1,a2);

    extern int sipVH_PyKDL_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&, ::Frame&,int);

    return sipVH_PyKDL_3(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainFkSolverPos_recursive_JntToCart, "JntToCart(self, q_in: JntArray, p_out: Frame, segmentNr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainFkSolverPos_recursive_JntToCart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverPos_recursive_JntToCart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::Frame* a1;
        int a2 = -1;
         ::ChainFkSolverPos_recursive *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_p_out,
            sipName_segmentNr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9|i", &sipSelf, sipType_ChainFkSolverPos_recursive, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainFkSolverPos_recursive::JntToCart(*a0,*a1,a2) : sipCpp->JntToCart(*a0,*a1,a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverPos_recursive, sipName_JntToCart, doc_ChainFkSolverPos_recursive_JntToCart);

    return NULL;
}


PyDoc_STRVAR(doc_ChainFkSolverPos_recursive_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainFkSolverPos_recursive_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverPos_recursive_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainFkSolverPos_recursive *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainFkSolverPos_recursive, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainFkSolverPos_recursive::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverPos_recursive, sipName_updateInternalDataStructures, doc_ChainFkSolverPos_recursive_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverPos_recursive(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverPos_recursive(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverPos_recursive *sipCpp = reinterpret_cast< ::ChainFkSolverPos_recursive *>(sipCppV);

    if (targetType == sipType_ChainFkSolverPos)
        return static_cast< ::ChainFkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverPos_recursive(void *, int);}
static void release_ChainFkSolverPos_recursive(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainFkSolverPos_recursive *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainFkSolverPos_recursive *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverPos_recursive(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverPos_recursive(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainFkSolverPos_recursive *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverPos_recursive(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainFkSolverPos_recursive(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainFkSolverPos_recursive(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainFkSolverPos_recursive *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainFkSolverPos_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainFkSolverPos_recursive* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainFkSolverPos_recursive, &a0))
        {
            sipCpp = new sipChainFkSolverPos_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverPos_recursive[] = {{2, 255, 1}};


static PyMethodDef methods_ChainFkSolverPos_recursive[] = {
    {SIP_MLNAME_CAST(sipName_JntToCart), (PyCFunction)meth_ChainFkSolverPos_recursive_JntToCart, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainFkSolverPos_recursive_JntToCart)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainFkSolverPos_recursive_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainFkSolverPos_recursive_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainFkSolverPos_recursive, "\1ChainFkSolverPos_recursive(chain: Chain)\n"
"ChainFkSolverPos_recursive(ChainFkSolverPos_recursive)");


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverPos_recursive = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverPos_recursive,
        {0},
        0
    },
    {
        sipNameNr_ChainFkSolverPos_recursive,
        {0, 0, 1},
        2, methods_ChainFkSolverPos_recursive,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainFkSolverPos_recursive,
    -1,
    -1,
    supers_ChainFkSolverPos_recursive,
    0,
    init_type_ChainFkSolverPos_recursive,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainFkSolverPos_recursive,
    0,
    0,
    0,
    release_ChainFkSolverPos_recursive,
    cast_ChainFkSolverPos_recursive,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 434 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 11431 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 11436 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 11440 "sip_PyKDL/sipPyKDLpart0.cpp"


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverVel(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverVel(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverVel *sipCpp = reinterpret_cast< ::ChainFkSolverVel *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverVel(void *, int);}
static void release_ChainFkSolverVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::ChainFkSolverVel *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverVel(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverVel(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverVel[] = {{32, 255, 1}};


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverVel,
        {0},
        0
    },
    {
        sipNameNr_ChainFkSolverVel,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    supers_ChainFkSolverVel,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainFkSolverVel,
    0,
    0,
    0,
    release_ChainFkSolverVel,
    cast_ChainFkSolverVel,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 425 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 11530 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 11535 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11541 "sip_PyKDL/sipPyKDLpart0.cpp"


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverPos(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverPos(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverPos *sipCpp = reinterpret_cast< ::ChainFkSolverPos *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverPos(void *, int);}
static void release_ChainFkSolverPos(void *sipCppV, int)
{
    delete reinterpret_cast< ::ChainFkSolverPos *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverPos(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverPos(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverPos(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverPos[] = {{32, 255, 1}};


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverPos = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverPos,
        {0},
        0
    },
    {
        sipNameNr_ChainFkSolverPos,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    supers_ChainFkSolverPos,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainFkSolverPos,
    0,
    0,
    0,
    release_ChainFkSolverPos,
    cast_ChainFkSolverPos,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 414 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/solveri.hpp>
using namespace KDL;
#line 11631 "sip_PyKDL/sipPyKDLpart0.cpp"



extern "C" {static PyObject *meth_SolverI_getError(PyObject *, PyObject *);}
static PyObject *meth_SolverI_getError(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_SolverI, sipName_getError, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_SolverI_strError(PyObject *, PyObject *);}
static PyObject *meth_SolverI_strError(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_SolverI, sipName_strError, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_SolverI(void *, int);}
static void release_SolverI(void *sipCppV, int)
{
    delete reinterpret_cast< ::SolverI *>(sipCppV);
}


extern "C" {static void dealloc_SolverI(sipSimpleWrapper *);}
static void dealloc_SolverI(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_SolverI(sipGetAddress(sipSelf), 0);
    }
}


static PyMethodDef methods_SolverI[] = {
    {SIP_MLNAME_CAST(sipName_getError), meth_SolverI_getError, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_strError), meth_SolverI_strError, METH_VARARGS, NULL}
};


sipClassTypeDef sipTypeDef_PyKDL_SolverI = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_SolverI,
        {0},
        0
    },
    {
        sipNameNr_SolverI,
        {0, 0, 1},
        2, methods_SolverI,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    0,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_SolverI,
    0,
    0,
    0,
    release_SolverI,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 358 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 11733 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11740 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 102 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11746 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11752 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 11758 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 11761 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Jacobian_rows, "rows(self) -> int");

extern "C" {static PyObject *meth_Jacobian_rows(PyObject *, PyObject *);}
static PyObject *meth_Jacobian_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Jacobian, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_rows, doc_Jacobian_rows);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_columns, "columns(self) -> int");

extern "C" {static PyObject *meth_Jacobian_columns(PyObject *, PyObject *);}
static PyObject *meth_Jacobian_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Jacobian, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_columns, doc_Jacobian_columns);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_resize, "resize(self, newNrOfColumns: int)");

extern "C" {static PyObject *meth_Jacobian_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newNrOfColumns,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Jacobian, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_resize, doc_Jacobian_resize);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_getColumn, "getColumn(self, i: int) -> Twist");

extern "C" {static PyObject *meth_Jacobian_getColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_getColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const  ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_i,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Jacobian, &sipCpp, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->getColumn(a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_getColumn, doc_Jacobian_getColumn);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_setColumn, "setColumn(self, i: int, t: Twist)");

extern "C" {static PyObject *meth_Jacobian_setColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_setColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const  ::Twist* a1;
         ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_i,
            sipName_t,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BuJ9", &sipSelf, sipType_Jacobian, &sipCpp, &a0, sipType_Twist, &a1))
        {
            sipCpp->setColumn(a0,*a1);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_setColumn, doc_Jacobian_setColumn);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_changeRefPoint, "changeRefPoint(self, base_AB: Vector)");

extern "C" {static PyObject *meth_Jacobian_changeRefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_changeRefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
         ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_base_AB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Jacobian, &sipCpp, sipType_Vector, &a0))
        {
            sipCpp->changeRefPoint(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_changeRefPoint, doc_Jacobian_changeRefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_changeBase, "changeBase(self, rot: Rotation)");

extern "C" {static PyObject *meth_Jacobian_changeBase(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_changeBase(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation* a0;
         ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Jacobian, &sipCpp, sipType_Rotation, &a0))
        {
            sipCpp->changeBase(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_changeBase, doc_Jacobian_changeBase);

    return NULL;
}


PyDoc_STRVAR(doc_Jacobian_changeRefFrame, "changeRefFrame(self, frame: Frame)");

extern "C" {static PyObject *meth_Jacobian_changeRefFrame(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Jacobian_changeRefFrame(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Frame* a0;
         ::Jacobian *sipCpp;

        static const char *sipKwdList[] = {
            sipName_frame,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Jacobian, &sipCpp, sipType_Frame, &a0))
        {
            sipCpp->changeRefFrame(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName_changeRefFrame, doc_Jacobian_changeRefFrame);

    return NULL;
}


extern "C" {static PyObject *slot_Jacobian___repr__(PyObject *);}
static PyObject *slot_Jacobian___repr__(PyObject *sipSelf)
{
     ::Jacobian *sipCpp = reinterpret_cast< ::Jacobian *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Jacobian));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 392 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<sipCpp->data;
    std::string s(ss.str());
    sipRes=&s;
#line 12033 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Jacobian___setitem__(PyObject *,PyObject *);}
static int slot_Jacobian___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Jacobian *sipCpp = reinterpret_cast< ::Jacobian *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Jacobian));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "Td", &PyTuple_Type, &a0, &a1))
        {
#line 381 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > 5 || j >= (int)sipCpp->columns()) {
        PyErr_SetString(PyExc_IndexError, "Jacobian index out of range");
        return 0;
    }
    (*sipCpp)(i,j)=a1;
#line 12067 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Jacobian___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Jacobian___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Jacobian *sipCpp = reinterpret_cast< ::Jacobian *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Jacobian));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 370 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > 5 || j >= (int)sipCpp->columns()) {
        PyErr_SetString(PyExc_IndexError, "Jacobian index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(i,j);
#line 12105 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Jacobian, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Jacobian(void *, int);}
static void release_Jacobian(void *sipCppV, int)
{
    delete reinterpret_cast< ::Jacobian *>(sipCppV);
}


extern "C" {static void dealloc_Jacobian(sipSimpleWrapper *);}
static void dealloc_Jacobian(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Jacobian(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Jacobian(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Jacobian(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Jacobian *sipCpp = 0;

    {
        uint a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "u", &a0))
        {
            sipCpp = new  ::Jacobian(a0);

            return sipCpp;
        }
    }

    {
        const  ::Jacobian* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Jacobian, &a0))
        {
            sipCpp = new  ::Jacobian(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Jacobian[] = {
    {(void *)slot_Jacobian___repr__, repr_slot},
    {(void *)slot_Jacobian___setitem__, setitem_slot},
    {(void *)slot_Jacobian___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Jacobian[] = {
    {SIP_MLNAME_CAST(sipName_changeBase), (PyCFunction)meth_Jacobian_changeBase, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_changeBase)},
    {SIP_MLNAME_CAST(sipName_changeRefFrame), (PyCFunction)meth_Jacobian_changeRefFrame, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_changeRefFrame)},
    {SIP_MLNAME_CAST(sipName_changeRefPoint), (PyCFunction)meth_Jacobian_changeRefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_changeRefPoint)},
    {SIP_MLNAME_CAST(sipName_columns), meth_Jacobian_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_Jacobian_columns)},
    {SIP_MLNAME_CAST(sipName_getColumn), (PyCFunction)meth_Jacobian_getColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_getColumn)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_Jacobian_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_Jacobian_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_Jacobian_rows)},
    {SIP_MLNAME_CAST(sipName_setColumn), (PyCFunction)meth_Jacobian_setColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Jacobian_setColumn)}
};

PyDoc_STRVAR(doc_Jacobian, "\1Jacobian(size: int)\n"
"Jacobian(arg: Jacobian)");


sipClassTypeDef sipTypeDef_PyKDL_Jacobian = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Jacobian,
        {0},
        0
    },
    {
        sipNameNr_Jacobian,
        {0, 0, 1},
        8, methods_Jacobian,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Jacobian,
    -1,
    -1,
    0,
    slots_Jacobian,
    init_type_Jacobian,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Jacobian,
    0,
    0,
    0,
    release_Jacobian,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 12253 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 12258 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_JntArrayVel_resize, "resize(self, newSize: int)");

extern "C" {static PyObject *meth_JntArrayVel_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntArrayVel_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::JntArrayVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntArrayVel, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArrayVel, sipName_resize, doc_JntArrayVel_resize);

    return NULL;
}


PyDoc_STRVAR(doc_JntArrayVel_value, "value(self) -> JntArray");

extern "C" {static PyObject *meth_JntArrayVel_value(PyObject *, PyObject *);}
static PyObject *meth_JntArrayVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArrayVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArrayVel, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArrayVel, sipName_value, doc_JntArrayVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_JntArrayVel_deriv, "deriv(self) -> JntArray");

extern "C" {static PyObject *meth_JntArrayVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_JntArrayVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArrayVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArrayVel, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArrayVel, sipName_deriv, doc_JntArrayVel_deriv);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntArrayVel(void *, int);}
static void release_JntArrayVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::JntArrayVel *>(sipCppV);
}


extern "C" {static void dealloc_JntArrayVel(sipSimpleWrapper *);}
static void dealloc_JntArrayVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_JntArrayVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_JntArrayVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntArrayVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::JntArrayVel *sipCpp = 0;

    {
        uint a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "u", &a0))
        {
            sipCpp = new  ::JntArrayVel(a0);

            return sipCpp;
        }
    }

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_qdot,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1))
        {
            sipCpp = new  ::JntArrayVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntArray, &a0))
        {
            sipCpp = new  ::JntArrayVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::JntArrayVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_JntArrayVel, &a0))
        {
            sipCpp = new  ::JntArrayVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_JntArrayVel[] = {
    {SIP_MLNAME_CAST(sipName_deriv), meth_JntArrayVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArrayVel_deriv)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntArrayVel_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntArrayVel_resize)},
    {SIP_MLNAME_CAST(sipName_value), meth_JntArrayVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArrayVel_value)}
};


extern "C" {static PyObject *varget_JntArrayVel_q(void *, PyObject *, PyObject *);}
static PyObject *varget_JntArrayVel_q(void *sipSelf, PyObject *, PyObject *)
{
     ::JntArray*sipVal;
     ::JntArrayVel *sipCpp = reinterpret_cast< ::JntArrayVel *>(sipSelf);

    sipVal = &sipCpp->q;

    return sipConvertFromType(sipVal, sipType_JntArray, NULL);
}


extern "C" {static int varset_JntArrayVel_q(void *, PyObject *, PyObject *);}
static int varset_JntArrayVel_q(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::JntArray*sipVal;
     ::JntArrayVel *sipCpp = reinterpret_cast< ::JntArrayVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::JntArray *>(sipForceConvertToType(sipPy,sipType_JntArray,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->q = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_JntArrayVel_qdot(void *, PyObject *, PyObject *);}
static PyObject *varget_JntArrayVel_qdot(void *sipSelf, PyObject *, PyObject *)
{
     ::JntArray*sipVal;
     ::JntArrayVel *sipCpp = reinterpret_cast< ::JntArrayVel *>(sipSelf);

    sipVal = &sipCpp->qdot;

    return sipConvertFromType(sipVal, sipType_JntArray, NULL);
}


extern "C" {static int varset_JntArrayVel_qdot(void *, PyObject *, PyObject *);}
static int varset_JntArrayVel_qdot(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::JntArray*sipVal;
     ::JntArrayVel *sipCpp = reinterpret_cast< ::JntArrayVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::JntArray *>(sipForceConvertToType(sipPy,sipType_JntArray,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->qdot = *sipVal;

    return 0;
}

sipVariableDef variables_JntArrayVel[] = {
    {InstanceVariable, sipName_q, (PyMethodDef *)varget_JntArrayVel_q, (PyMethodDef *)varset_JntArrayVel_q, NULL, NULL},
    {InstanceVariable, sipName_qdot, (PyMethodDef *)varget_JntArrayVel_qdot, (PyMethodDef *)varset_JntArrayVel_qdot, NULL, NULL},
};

PyDoc_STRVAR(doc_JntArrayVel, "\1JntArrayVel(size: int)\n"
"JntArrayVel(q: JntArray, qdot: JntArray)\n"
"JntArrayVel(q: JntArray)\n"
"JntArrayVel(JntArrayVel)");


sipClassTypeDef sipTypeDef_PyKDL_JntArrayVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntArrayVel,
        {0},
        0
    },
    {
        sipNameNr_JntArrayVel,
        {0, 0, 1},
        3, methods_JntArrayVel,
        0, 0,
        2, variables_JntArrayVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntArrayVel,
    -1,
    -1,
    0,
    0,
    init_type_JntArrayVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntArrayVel,
    0,
    0,
    0,
    release_JntArrayVel,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 277 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 12569 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 12573 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_JntArray_rows, "rows(self) -> int");

extern "C" {static PyObject *meth_JntArray_rows(PyObject *, PyObject *);}
static PyObject *meth_JntArray_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_rows, doc_JntArray_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_columns, "columns(self) -> int");

extern "C" {static PyObject *meth_JntArray_columns(PyObject *, PyObject *);}
static PyObject *meth_JntArray_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_columns, doc_JntArray_columns);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_resize, "resize(self, newSize: int)");

extern "C" {static PyObject *meth_JntArray_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntArray_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::JntArray *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntArray, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_resize, doc_JntArray_resize);

    return NULL;
}


extern "C" {static PyObject *slot_JntArray___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_JntArray, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntArray___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_JntArray, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntArray___repr__(PyObject *);}
static PyObject *slot_JntArray___repr__(PyObject *sipSelf)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 308 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<sipCpp->data;
    std::string s(ss.str());
    sipRes=&s;
#line 12746 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_JntArray___setitem__(PyObject *,PyObject *);}
static int slot_JntArray___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 299 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 12778 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_JntArray___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 290 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 12814 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntArray(void *, int);}
static void release_JntArray(void *sipCppV, int)
{
    delete reinterpret_cast< ::JntArray *>(sipCppV);
}


extern "C" {static void dealloc_JntArray(sipSimpleWrapper *);}
static void dealloc_JntArray(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_JntArray(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_JntArray(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntArray(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::JntArray *sipCpp = 0;

    {
        uint a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "u", &a0))
        {
            sipCpp = new  ::JntArray(a0);

            return sipCpp;
        }
    }

    {
        const  ::JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntArray, &a0))
        {
            sipCpp = new  ::JntArray(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntArray[] = {
    {(void *)slot_JntArray___ne__, ne_slot},
    {(void *)slot_JntArray___eq__, eq_slot},
    {(void *)slot_JntArray___repr__, repr_slot},
    {(void *)slot_JntArray___setitem__, setitem_slot},
    {(void *)slot_JntArray___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntArray[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntArray_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_columns)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntArray_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntArray_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntArray_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_rows)}
};

PyDoc_STRVAR(doc_JntArray, "\1JntArray(size: int)\n"
"JntArray(arg: JntArray)");


sipClassTypeDef sipTypeDef_PyKDL_JntArray = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntArray,
        {0},
        0
    },
    {
        sipNameNr_JntArray,
        {0, 0, 1},
        3, methods_JntArray,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntArray,
    -1,
    -1,
    0,
    slots_JntArray,
    init_type_JntArray,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntArray,
    0,
    0,
    0,
    release_JntArray,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 258 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 12959 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 12963 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 12967 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 208 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 12972 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Tree_addSegment, "addSegment(self, segment: Segment, hook_name: object) -> bool");

extern "C" {static PyObject *meth_Tree_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
        const  ::std::string* a1;
        int a1State = 0;
         ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
            sipName_hook_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J1", &sipSelf, sipType_Tree, &sipCpp, sipType_Segment, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->addSegment(*a0,*a1);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_addSegment, doc_Tree_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfJoints, doc_Tree_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfSegments, doc_Tree_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getChain, "getChain(self, chain_root: object, chain_tip: object) -> Chain");

extern "C" {static PyObject *meth_Tree_getChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_getChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::std::string* a1;
        int a1State = 0;
        const  ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain_root,
            sipName_chain_tip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_Tree, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
             ::Chain*sipRes = 0;

#line 268 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    Chain* chain = new Chain();
    sipCpp->getChain(*a0, *a1, *chain);
    sipRes = chain;
#line 13096 "sip_PyKDL/sipPyKDLpart0.cpp"
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_Chain,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getChain, doc_Tree_getChain);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Tree(void *, int);}
static void release_Tree(void *sipCppV, int)
{
    delete reinterpret_cast< ::Tree *>(sipCppV);
}


extern "C" {static void assign_Tree(void *, SIP_SSIZE_T, void *);}
static void assign_Tree(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Tree *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Tree *>(sipSrc);
}


extern "C" {static void *array_Tree(SIP_SSIZE_T);}
static void *array_Tree(SIP_SSIZE_T sipNrElem)
{
    return new  ::Tree[sipNrElem];
}


extern "C" {static void *copy_Tree(const void *, SIP_SSIZE_T);}
static void *copy_Tree(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Tree(reinterpret_cast<const  ::Tree *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Tree(sipSimpleWrapper *);}
static void dealloc_Tree(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Tree(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Tree(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Tree(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Tree *sipCpp = 0;

    {
        const  ::std::string& a0def = "root";
        const  ::std::string* a0 = &a0def;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_root_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J1", sipType_std_string,&a0, &a0State))
        {
            sipCpp = new  ::Tree(*a0);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Tree* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Tree, &a0))
        {
            sipCpp = new  ::Tree(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Tree[] = {
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Tree_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_addSegment)},
    {SIP_MLNAME_CAST(sipName_getChain), (PyCFunction)meth_Tree_getChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_getChain)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Tree_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Tree_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfSegments)}
};

PyDoc_STRVAR(doc_Tree, "\1Tree(root_name: object = \"root\")\n"
"Tree(Tree)");


sipClassTypeDef sipTypeDef_PyKDL_Tree = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Tree,
        {0},
        0
    },
    {
        sipNameNr_Tree,
        {0, 0, 1},
        4, methods_Tree,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Tree,
    -1,
    -1,
    0,
    0,
    init_type_Tree,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Tree,
    assign_Tree,
    array_Tree,
    copy_Tree,
    release_Tree,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 238 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 13253 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 208 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 13259 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Chain_addSegment, "addSegment(self, segment: Segment)");

extern "C" {static PyObject *meth_Chain_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Segment, &a0))
        {
            sipCpp->addSegment(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addSegment, doc_Chain_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_addChain, "addChain(self, chain: Chain)");

extern "C" {static PyObject *meth_Chain_addChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Chain, &a0))
        {
            sipCpp->addChain(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addChain, doc_Chain_addChain);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfJoints, doc_Chain_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfSegments, doc_Chain_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getSegment, "getSegment(self, nr: int) -> Segment");

extern "C" {static PyObject *meth_Chain_getSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_getSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const  ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Chain, &sipCpp, &a0))
        {
             ::Segment*sipRes;

            sipRes = new  ::Segment(sipCpp->getSegment(a0));

            return sipConvertFromNewType(sipRes,sipType_Segment,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getSegment, doc_Chain_getSegment);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Chain(void *, int);}
static void release_Chain(void *sipCppV, int)
{
    delete reinterpret_cast< ::Chain *>(sipCppV);
}


extern "C" {static void assign_Chain(void *, SIP_SSIZE_T, void *);}
static void assign_Chain(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Chain *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Chain *>(sipSrc);
}


extern "C" {static void *array_Chain(SIP_SSIZE_T);}
static void *array_Chain(SIP_SSIZE_T sipNrElem)
{
    return new  ::Chain[sipNrElem];
}


extern "C" {static void *copy_Chain(const void *, SIP_SSIZE_T);}
static void *copy_Chain(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Chain(reinterpret_cast<const  ::Chain *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Chain(sipSimpleWrapper *);}
static void dealloc_Chain(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Chain(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Chain(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Chain(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Chain *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Chain();

            return sipCpp;
        }
    }

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new  ::Chain(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Chain[] = {
    {SIP_MLNAME_CAST(sipName_addChain), (PyCFunction)meth_Chain_addChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addChain)},
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Chain_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addSegment)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Chain_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Chain_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfSegments)},
    {SIP_MLNAME_CAST(sipName_getSegment), (PyCFunction)meth_Chain_getSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_getSegment)}
};

PyDoc_STRVAR(doc_Chain, "\1Chain()\n"
"Chain(in_: Chain)");


sipClassTypeDef sipTypeDef_PyKDL_Chain = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Chain,
        {0},
        0
    },
    {
        sipNameNr_Chain,
        {0, 0, 1},
        5, methods_Chain,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Chain,
    -1,
    -1,
    0,
    0,
    init_type_Chain,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Chain,
    assign_Chain,
    array_Chain,
    copy_Chain,
    release_Chain,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 208 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 13554 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 13558 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 111 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 13563 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 13569 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 186 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 13574 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 13580 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Segment_getFrameToTip, "getFrameToTip(self) -> Frame");

extern "C" {static PyObject *meth_Segment_getFrameToTip(PyObject *, PyObject *);}
static PyObject *meth_Segment_getFrameToTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->getFrameToTip());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getFrameToTip, doc_Segment_getFrameToTip);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_pose, "pose(self, q: float) -> Frame");

extern "C" {static PyObject *meth_Segment_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Segment, &sipCpp, &a0))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_pose, doc_Segment_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_twist, "twist(self, q: float, qdot: float) -> Twist");

extern "C" {static PyObject *meth_Segment_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_Segment, &sipCpp, &a0, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->twist(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_twist, doc_Segment_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getName, "getName(self) -> object");

extern "C" {static PyObject *meth_Segment_getName(PyObject *, PyObject *);}
static PyObject *meth_Segment_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getName, doc_Segment_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getJoint, "getJoint(self) -> Joint");

extern "C" {static PyObject *meth_Segment_getJoint(PyObject *, PyObject *);}
static PyObject *meth_Segment_getJoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Joint*sipRes;

            sipRes = new  ::Joint(sipCpp->getJoint());

            return sipConvertFromNewType(sipRes,sipType_Joint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getJoint, doc_Segment_getJoint);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getInertia, "getInertia(self) -> RigidBodyInertia");

extern "C" {static PyObject *meth_Segment_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->getInertia());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getInertia, doc_Segment_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_setInertia, "setInertia(self, Iin: RigidBodyInertia)");

extern "C" {static PyObject *meth_Segment_setInertia(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_setInertia(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
         ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_Iin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Segment, &sipCpp, sipType_RigidBodyInertia, &a0))
        {
            sipCpp->setInertia(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_setInertia, doc_Segment_setInertia);

    return NULL;
}


extern "C" {static PyObject *slot_Segment___repr__(PyObject *);}
static PyObject *slot_Segment___repr__(PyObject *sipSelf)
{
     ::Segment *sipCpp = reinterpret_cast< ::Segment *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Segment));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 219 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<(*sipCpp);
    std::string s(ss.str());
    sipRes=&s;
#line 13813 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Segment(void *, int);}
static void release_Segment(void *sipCppV, int)
{
    delete reinterpret_cast< ::Segment *>(sipCppV);
}


extern "C" {static void assign_Segment(void *, SIP_SSIZE_T, void *);}
static void assign_Segment(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Segment *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Segment *>(sipSrc);
}


extern "C" {static void *array_Segment(SIP_SSIZE_T);}
static void *array_Segment(SIP_SSIZE_T sipNrElem)
{
    return new  ::Segment[sipNrElem];
}


extern "C" {static void *copy_Segment(const void *, SIP_SSIZE_T);}
static void *copy_Segment(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Segment(reinterpret_cast<const  ::Segment *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Segment(sipSimpleWrapper *);}
static void dealloc_Segment(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Segment(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Segment(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Segment(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Segment *sipCpp = 0;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::Joint& a1def = Joint(Joint::None);
        const  ::Joint* a1 = &a1def;
        const  ::Frame& a2def = Frame::Identity();
        const  ::Frame* a2 = &a2def;
        const  ::RigidBodyInertia& a3def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a3 = &a3def;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|J9J9J9", sipType_std_string,&a0, &a0State, sipType_Joint, &a1, sipType_Frame, &a2, sipType_RigidBodyInertia, &a3))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Joint& a0def = Joint(Joint::None);
        const  ::Joint* a0 = &a0def;
        const  ::Frame& a1def = Frame::Identity();
        const  ::Frame* a1 = &a1def;
        const  ::RigidBodyInertia& a2def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J9J9J9", sipType_Joint, &a0, sipType_Frame, &a1, sipType_RigidBodyInertia, &a2))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::Segment* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Segment, &a0))
        {
            sipCpp = new  ::Segment(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Segment[] = {
    {(void *)slot_Segment___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Segment[] = {
    {SIP_MLNAME_CAST(sipName_getFrameToTip), meth_Segment_getFrameToTip, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getFrameToTip)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Segment_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getInertia)},
    {SIP_MLNAME_CAST(sipName_getJoint), meth_Segment_getJoint, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getJoint)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Segment_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Segment_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_pose)},
    {SIP_MLNAME_CAST(sipName_setInertia), (PyCFunction)meth_Segment_setInertia, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_setInertia)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Segment_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_twist)}
};

PyDoc_STRVAR(doc_Segment, "\1Segment(name: object, joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(in_: Segment)");


sipClassTypeDef sipTypeDef_PyKDL_Segment = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Segment,
        {0},
        0
    },
    {
        sipNameNr_Segment,
        {0, 0, 1},
        7, methods_Segment,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Segment,
    -1,
    -1,
    0,
    slots_Segment,
    init_type_Segment,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Segment,
    assign_Segment,
    array_Segment,
    copy_Segment,
    release_Segment,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 186 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 14012 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14019 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 150 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 14024 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14030 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14036 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_RigidBodyInertia_Zero, "Zero() -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia( ::RigidBodyInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_Zero, doc_RigidBodyInertia_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_RefPoint, "RefPoint(self, p: Vector) -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
         ::RigidBodyInertia *sipCpp;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RigidBodyInertia, &sipCpp, sipType_Vector, &a0))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_RefPoint, doc_RigidBodyInertia_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getMass, "getMass(self) -> float");

extern "C" {static PyObject *meth_RigidBodyInertia_getMass(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getMass();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getMass, doc_RigidBodyInertia_getMass);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getCOG, "getCOG(self) -> Vector");

extern "C" {static PyObject *meth_RigidBodyInertia_getCOG(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getCOG(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->getCOG());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getCOG, doc_RigidBodyInertia_getCOG);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getRotationalInertia, "getRotationalInertia(self) -> RotationalInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia(sipCpp->getRotationalInertia());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getRotationalInertia, doc_RigidBodyInertia_getRotationalInertia);

    return NULL;
}


extern "C" {static PyObject *slot_RigidBodyInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const  ::RigidBodyInertia* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_Twist, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_RigidBodyInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_RigidBodyInertia(void *, int);}
static void release_RigidBodyInertia(void *sipCppV, int)
{
    delete reinterpret_cast< ::RigidBodyInertia *>(sipCppV);
}


extern "C" {static void assign_RigidBodyInertia(void *, SIP_SSIZE_T, void *);}
static void assign_RigidBodyInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RigidBodyInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RigidBodyInertia *>(sipSrc);
}


extern "C" {static void *array_RigidBodyInertia(SIP_SSIZE_T);}
static void *array_RigidBodyInertia(SIP_SSIZE_T sipNrElem)
{
    return new  ::RigidBodyInertia[sipNrElem];
}


extern "C" {static void *copy_RigidBodyInertia(const void *, SIP_SSIZE_T);}
static void *copy_RigidBodyInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RigidBodyInertia(reinterpret_cast<const  ::RigidBodyInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RigidBodyInertia(sipSimpleWrapper *);}
static void dealloc_RigidBodyInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RigidBodyInertia(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RigidBodyInertia *sipCpp = 0;

    {
        double a0 = 0;
        const  ::Vector& a1def = Vector::Zero();
        const  ::Vector* a1 = &a1def;
        const  ::RotationalInertia& a2def = RotationalInertia::Zero();
        const  ::RotationalInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_m,
            sipName_oc,
            sipName_Ic,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dJ9J9", &a0, sipType_Vector, &a1, sipType_RotationalInertia, &a2))
        {
            sipCpp = new  ::RigidBodyInertia(a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::RigidBodyInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RigidBodyInertia, &a0))
        {
            sipCpp = new  ::RigidBodyInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RigidBodyInertia[] = {
    {(void *)slot_RigidBodyInertia___mul__, mul_slot},
    {(void *)slot_RigidBodyInertia___add__, add_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RigidBodyInertia[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_RigidBodyInertia_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RigidBodyInertia_RefPoint)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_RigidBodyInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_Zero)},
    {SIP_MLNAME_CAST(sipName_getCOG), meth_RigidBodyInertia_getCOG, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getCOG)},
    {SIP_MLNAME_CAST(sipName_getMass), meth_RigidBodyInertia_getMass, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getMass)},
    {SIP_MLNAME_CAST(sipName_getRotationalInertia), meth_RigidBodyInertia_getRotationalInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getRotationalInertia)}
};

PyDoc_STRVAR(doc_RigidBodyInertia, "\1RigidBodyInertia(m: float = 0, oc: Vector = Vector.Zero(), Ic: RotationalInertia = RotationalInertia.Zero())\n"
"RigidBodyInertia(RigidBodyInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RigidBodyInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RigidBodyInertia,
        {0},
        0
    },
    {
        sipNameNr_RigidBodyInertia,
        {0, 0, 1},
        5, methods_RigidBodyInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RigidBodyInertia,
    -1,
    -1,
    0,
    slots_RigidBodyInertia,
    init_type_RigidBodyInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RigidBodyInertia,
    assign_RigidBodyInertia,
    array_RigidBodyInertia,
    copy_RigidBodyInertia,
    release_RigidBodyInertia,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 150 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 14407 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14414 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_RotationalInertia_Zero, "Zero() -> RotationalInertia");

extern "C" {static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia( ::RotationalInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName_Zero, doc_RotationalInertia_Zero);

    return NULL;
}


extern "C" {static PyObject *slot_RotationalInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::RotationalInertia* a0;
         ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        double a0;
        const  ::RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RotationalInertia, &a1))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_RotationalInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationalInertia* a0;
        const  ::RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_RotationalInertia, &a1))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static int slot_RotationalInertia___setitem__(PyObject *,PyObject *);}
static int slot_RotationalInertia___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::RotationalInertia *sipCpp = reinterpret_cast< ::RotationalInertia *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_RotationalInertia));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 170 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= 9) {
        PyErr_SetString(PyExc_IndexError, "RotationalInertia index out of range");
        return 0;
    }
    (*sipCpp).data[a0]=a1;
#line 14535 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_RotationalInertia___getitem__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::RotationalInertia *sipCpp = reinterpret_cast< ::RotationalInertia *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_RotationalInertia));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 161 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= 9) {
        PyErr_SetString(PyExc_IndexError, "RotationalInertia index out of range");
        return 0;
    }
    sipRes=(*sipCpp).data[a0];
#line 14571 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_RotationalInertia(void *, int);}
static void release_RotationalInertia(void *sipCppV, int)
{
    delete reinterpret_cast< ::RotationalInertia *>(sipCppV);
}


extern "C" {static void assign_RotationalInertia(void *, SIP_SSIZE_T, void *);}
static void assign_RotationalInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RotationalInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RotationalInertia *>(sipSrc);
}


extern "C" {static void *array_RotationalInertia(SIP_SSIZE_T);}
static void *array_RotationalInertia(SIP_SSIZE_T sipNrElem)
{
    return new  ::RotationalInertia[sipNrElem];
}


extern "C" {static void *copy_RotationalInertia(const void *, SIP_SSIZE_T);}
static void *copy_RotationalInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RotationalInertia(reinterpret_cast<const  ::RotationalInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RotationalInertia(sipSimpleWrapper *);}
static void dealloc_RotationalInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RotationalInertia(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RotationalInertia *sipCpp = 0;

    {
        double a0 = 0;
        double a1 = 0;
        double a2 = 0;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;

        static const char *sipKwdList[] = {
            sipName_Ixx,
            sipName_Iyy,
            sipName_Izz,
            sipName_Ixy,
            sipName_Ixz,
            sipName_Iyz,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dddddd", &a0, &a1, &a2, &a3, &a4, &a5))
        {
            sipCpp = new  ::RotationalInertia(a0,a1,a2,a3,a4,a5);

            return sipCpp;
        }
    }

    {
        const  ::RotationalInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RotationalInertia, &a0))
        {
            sipCpp = new  ::RotationalInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RotationalInertia[] = {
    {(void *)slot_RotationalInertia___mul__, mul_slot},
    {(void *)slot_RotationalInertia___add__, add_slot},
    {(void *)slot_RotationalInertia___setitem__, setitem_slot},
    {(void *)slot_RotationalInertia___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RotationalInertia[] = {
    {SIP_MLNAME_CAST(sipName_Zero), meth_RotationalInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationalInertia_Zero)}
};

PyDoc_STRVAR(doc_RotationalInertia, "\1RotationalInertia(Ixx: float = 0, Iyy: float = 0, Izz: float = 0, Ixy: float = 0, Ixz: float = 0, Iyz: float = 0)\n"
"RotationalInertia(RotationalInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RotationalInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RotationalInertia,
        {0},
        0
    },
    {
        sipNameNr_RotationalInertia,
        {0, 0, 1},
        1, methods_RotationalInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RotationalInertia,
    -1,
    -1,
    0,
    slots_RotationalInertia,
    init_type_RotationalInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RotationalInertia,
    assign_RotationalInertia,
    array_RotationalInertia,
    copy_RotationalInertia,
    release_RotationalInertia,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 111 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 14741 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 14745 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14751 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14757 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 14763 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Joint_pose, "pose(self, q: float) -> Frame");

extern "C" {static PyObject *meth_Joint_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Joint_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Joint *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Joint, &sipCpp, &a0))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_pose, doc_Joint_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_twist, "twist(self, qdot: float) -> Twist");

extern "C" {static PyObject *meth_Joint_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Joint_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Joint *sipCpp;

        static const char *sipKwdList[] = {
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Joint, &sipCpp, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->twist(a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_twist, doc_Joint_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_JointAxis, "JointAxis(self) -> Vector");

extern "C" {static PyObject *meth_Joint_JointAxis(PyObject *, PyObject *);}
static PyObject *meth_Joint_JointAxis(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->JointAxis());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_JointAxis, doc_Joint_JointAxis);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_JointOrigin, "JointOrigin(self) -> Vector");

extern "C" {static PyObject *meth_Joint_JointOrigin(PyObject *, PyObject *);}
static PyObject *meth_Joint_JointOrigin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->JointOrigin());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_JointOrigin, doc_Joint_JointOrigin);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getName, "getName(self) -> object");

extern "C" {static PyObject *meth_Joint_getName(PyObject *, PyObject *);}
static PyObject *meth_Joint_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getName, doc_Joint_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getType, "getType(self) -> Joint.JointType");

extern "C" {static PyObject *meth_Joint_getType(PyObject *, PyObject *);}
static PyObject *meth_Joint_getType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Joint::JointType sipRes;

            sipRes = sipCpp->getType();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_Joint_JointType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getType, doc_Joint_getType);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getTypeName, "getTypeName(self) -> object");

extern "C" {static PyObject *meth_Joint_getTypeName(PyObject *, PyObject *);}
static PyObject *meth_Joint_getTypeName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getTypeName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getTypeName, doc_Joint_getTypeName);

    return NULL;
}


extern "C" {static PyObject *slot_Joint___repr__(PyObject *);}
static PyObject *slot_Joint___repr__(PyObject *sipSelf)
{
     ::Joint *sipCpp = reinterpret_cast< ::Joint *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Joint));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 140 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
        std::ostringstream oss;
        oss<<(*sipCpp);
        std::string s(oss.str());
        sipRes=&s;
#line 14990 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Joint(void *, int);}
static void release_Joint(void *sipCppV, int)
{
    delete reinterpret_cast< ::Joint *>(sipCppV);
}


extern "C" {static void assign_Joint(void *, SIP_SSIZE_T, void *);}
static void assign_Joint(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Joint *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Joint *>(sipSrc);
}


extern "C" {static void *array_Joint(SIP_SSIZE_T);}
static void *array_Joint(SIP_SSIZE_T sipNrElem)
{
    return new  ::Joint[sipNrElem];
}


extern "C" {static void *copy_Joint(const void *, SIP_SSIZE_T);}
static void *copy_Joint(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Joint(reinterpret_cast<const  ::Joint *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Joint(sipSimpleWrapper *);}
static void dealloc_Joint(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Joint(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Joint(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Joint(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Joint *sipCpp = 0;

    {
         ::std::string* a0;
        int a0State = 0;
         ::Joint::JointType a1 =  ::Joint::None;
        double a2 = 1;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;
        double a6 = 0;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|Eddddd", sipType_std_string,&a0, &a0State, sipType_Joint_JointType, &a1, &a2, &a3, &a4, &a5, &a6))
        {
            sipCpp = new  ::Joint(*a0,a1,a2,a3,a4,a5,a6);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
         ::Joint::JointType a0 =  ::Joint::None;
        double a1 = 1;
        double a2 = 0;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;

        static const char *sipKwdList[] = {
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|Eddddd", sipType_Joint_JointType, &a0, &a1, &a2, &a3, &a4, &a5))
        {
            sipCpp = new  ::Joint(a0,a1,a2,a3,a4,a5);

            return sipCpp;
        }
    }

    {
         ::std::string* a0;
        int a0State = 0;
         ::Vector* a1;
         ::Vector* a2;
         ::Joint::JointType a3;
        double a4 = 1;
        double a5 = 0;
        double a6 = 0;
        double a7 = 0;
        double a8 = 0;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_origin,
            sipName_axis,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J9J9E|ddddd", sipType_std_string,&a0, &a0State, sipType_Vector, &a1, sipType_Vector, &a2, sipType_Joint_JointType, &a3, &a4, &a5, &a6, &a7, &a8))
        {
            sipCpp = new  ::Joint(*a0,*a1,*a2,a3,a4,a5,a6,a7,a8);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
         ::Vector* a0;
         ::Vector* a1;
         ::Joint::JointType a2;
        double a3 = 1;
        double a4 = 0;
        double a5 = 0;
        double a6 = 0;
        double a7 = 0;

        static const char *sipKwdList[] = {
            sipName_origin,
            sipName_axis,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9E|ddddd", sipType_Vector, &a0, sipType_Vector, &a1, sipType_Joint_JointType, &a2, &a3, &a4, &a5, &a6, &a7))
        {
            sipCpp = new  ::Joint(*a0,*a1,a2,a3,a4,a5,a6,a7);

            return sipCpp;
        }
    }

    {
        const  ::Joint* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Joint, &a0))
        {
            sipCpp = new  ::Joint(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Joint[] = {
    {(void *)slot_Joint___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Joint[] = {
    {SIP_MLNAME_CAST(sipName_JointAxis), meth_Joint_JointAxis, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_JointAxis)},
    {SIP_MLNAME_CAST(sipName_JointOrigin), meth_Joint_JointOrigin, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_JointOrigin)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Joint_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getName)},
    {SIP_MLNAME_CAST(sipName_getType), meth_Joint_getType, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getType)},
    {SIP_MLNAME_CAST(sipName_getTypeName), meth_Joint_getTypeName, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getTypeName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Joint_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Joint_pose)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Joint_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Joint_twist)}
};

static sipEnumMemberDef enummembers_Joint[] = {
    {sipName_None, static_cast<int>( ::Joint::None), 26},
    {sipName_RotAxis, static_cast<int>( ::Joint::RotAxis), 26},
    {sipName_RotX, static_cast<int>( ::Joint::RotX), 26},
    {sipName_RotY, static_cast<int>( ::Joint::RotY), 26},
    {sipName_RotZ, static_cast<int>( ::Joint::RotZ), 26},
    {sipName_TransAxis, static_cast<int>( ::Joint::TransAxis), 26},
    {sipName_TransX, static_cast<int>( ::Joint::TransX), 26},
    {sipName_TransY, static_cast<int>( ::Joint::TransY), 26},
    {sipName_TransZ, static_cast<int>( ::Joint::TransZ), 26},
};

PyDoc_STRVAR(doc_Joint, "\1Joint(name: object, type: Joint.JointType = Joint.None, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(type: Joint.JointType = Joint.None, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(name: object, origin: Vector, axis: Vector, type: Joint.JointType, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(origin: Vector, axis: Vector, type: Joint.JointType, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(in_: Joint)");


sipClassTypeDef sipTypeDef_PyKDL_Joint = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Joint,
        {0},
        0
    },
    {
        sipNameNr_Joint,
        {0, 0, 1},
        7, methods_Joint,
        9, enummembers_Joint,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Joint,
    -1,
    -1,
    0,
    slots_Joint,
    init_type_Joint,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Joint,
    assign_Joint,
    array_Joint,
    copy_Joint,
    release_Joint,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 15274 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 15281 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 15284 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Wrench_Zero, "Zero() -> Wrench");

extern "C" {static PyObject *meth_Wrench_Zero(PyObject *, PyObject *);}
static PyObject *meth_Wrench_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench( ::Wrench::Zero());

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Wrench, sipName_Zero, doc_Wrench_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_Wrench_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_Wrench_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_Wrench_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::Wrench *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Wrench, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Wrench, sipName_ReverseSign, doc_Wrench_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_Wrench_RefPoint, "RefPoint(self, v_base_AB: Vector) -> Wrench");

extern "C" {static PyObject *meth_Wrench_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Wrench_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Wrench *sipCpp;

        static const char *sipKwdList[] = {
            sipName_v_base_AB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Wrench, &sipCpp, sipType_Vector, &a0))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Wrench, sipName_RefPoint, doc_Wrench_RefPoint);

    return NULL;
}


extern "C" {static PyObject *slot_Wrench___neg__(PyObject *);}
static PyObject *slot_Wrench___neg__(PyObject *sipSelf)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;


    {
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_Wrench___mul__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Wrench, &a0, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        double a0;
        const  ::Wrench* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_Wrench, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Wrench___div__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Wrench, &a0, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Wrench___add__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Wrench, &a0, sipType_Wrench, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Wrench___sub__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Wrench, &a0, sipType_Wrench, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Wrench___eq__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Wrench, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_Wrench, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Wrench___ne__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Wrench, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_Wrench, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Wrench___repr__(PyObject *);}
static PyObject *slot_Wrench___repr__(PyObject *sipSelf)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 389 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    std::ostringstream oss;
    oss<<(*sipCpp);
    std::string s(oss.str());
    sipRes=&s;
#line 15604 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Wrench___setitem__(PyObject *,PyObject *);}
static int slot_Wrench___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 380 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 5) {
        PyErr_SetString(PyExc_IndexError, "Wrench index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 15636 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Wrench, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Wrench___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 371 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 5) {
        PyErr_SetString(PyExc_IndexError, "Wrench index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 15672 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Wrench, sipName___getitem__, NULL);

    return 0;
}


extern "C" {static PyObject *slot_Wrench___iadd__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Wrench)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Wrench, &a0))
        {
            sipCpp-> ::Wrench::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_Wrench___isub__(PyObject *,PyObject *);}
static PyObject *slot_Wrench___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Wrench)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Wrench));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Wrench* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Wrench, &a0))
        {
            sipCpp-> ::Wrench::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_Wrench(void *, int);}
static void release_Wrench(void *sipCppV, int)
{
    delete reinterpret_cast< ::Wrench *>(sipCppV);
}


extern "C" {static PyObject *pickle_Wrench(void *);}
static PyObject *pickle_Wrench(void *sipCppV)
{
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipCppV);
    PyObject *sipRes;

#line 400 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    const sipTypeDef *vector_type = sipFindType("Vector");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->force), vector_type, Py_None),
                                 sipConvertFromType(&(sipCpp->torque), vector_type, Py_None));
#line 15783 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_Wrench(void *, SIP_SSIZE_T, void *);}
static void assign_Wrench(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Wrench *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Wrench *>(sipSrc);
}


extern "C" {static void *array_Wrench(SIP_SSIZE_T);}
static void *array_Wrench(SIP_SSIZE_T sipNrElem)
{
    return new  ::Wrench[sipNrElem];
}


extern "C" {static void *copy_Wrench(const void *, SIP_SSIZE_T);}
static void *copy_Wrench(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Wrench(reinterpret_cast<const  ::Wrench *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Wrench(sipSimpleWrapper *);}
static void dealloc_Wrench(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Wrench(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Wrench(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Wrench(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Wrench *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Wrench();

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_force,
            sipName_torque,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::Wrench(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Wrench* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Wrench, &a0))
        {
            sipCpp = new  ::Wrench(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Wrench[] = {
    {(void *)slot_Wrench___neg__, neg_slot},
    {(void *)slot_Wrench___mul__, mul_slot},
    {(void *)slot_Wrench___div__, div_slot},
    {(void *)slot_Wrench___add__, add_slot},
    {(void *)slot_Wrench___sub__, sub_slot},
    {(void *)slot_Wrench___eq__, eq_slot},
    {(void *)slot_Wrench___ne__, ne_slot},
    {(void *)slot_Wrench___repr__, repr_slot},
    {(void *)slot_Wrench___setitem__, setitem_slot},
    {(void *)slot_Wrench___getitem__, getitem_slot},
    {(void *)slot_Wrench___iadd__, iadd_slot},
    {(void *)slot_Wrench___isub__, isub_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Wrench[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_Wrench_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Wrench_RefPoint)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_Wrench_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_Wrench_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_Wrench_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_Wrench_Zero)}
};


extern "C" {static PyObject *varget_Wrench_force(void *, PyObject *, PyObject *);}
static PyObject *varget_Wrench_force(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipSelf);

    sipVal = &sipCpp->force;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_Wrench_force(void *, PyObject *, PyObject *);}
static int varset_Wrench_force(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->force = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_Wrench_torque(void *, PyObject *, PyObject *);}
static PyObject *varget_Wrench_torque(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipSelf);

    sipVal = &sipCpp->torque;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_Wrench_torque(void *, PyObject *, PyObject *);}
static int varset_Wrench_torque(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::Wrench *sipCpp = reinterpret_cast< ::Wrench *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->torque = *sipVal;

    return 0;
}

sipVariableDef variables_Wrench[] = {
    {InstanceVariable, sipName_force, (PyMethodDef *)varget_Wrench_force, (PyMethodDef *)varset_Wrench_force, NULL, NULL},
    {InstanceVariable, sipName_torque, (PyMethodDef *)varget_Wrench_torque, (PyMethodDef *)varset_Wrench_torque, NULL, NULL},
};

PyDoc_STRVAR(doc_Wrench, "\1Wrench()\n"
"Wrench(force: Vector, torque: Vector)\n"
"Wrench(Wrench)");


sipClassTypeDef sipTypeDef_PyKDL_Wrench = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Wrench,
        {0},
        0
    },
    {
        sipNameNr_Wrench,
        {0, 0, 1},
        3, methods_Wrench,
        0, 0,
        2, variables_Wrench,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Wrench,
    -1,
    -1,
    0,
    slots_Wrench,
    init_type_Wrench,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Wrench,
    assign_Wrench,
    array_Wrench,
    copy_Wrench,
    release_Wrench,
    0,
    0,
    0,
    0,
    pickle_Wrench,
    0,
    0
};

#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16019 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16026 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 16029 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Twist_Zero, "Zero() -> Twist");

extern "C" {static PyObject *meth_Twist_Zero(PyObject *, PyObject *);}
static PyObject *meth_Twist_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist( ::Twist::Zero());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Twist, sipName_Zero, doc_Twist_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_Twist_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_Twist_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_Twist_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::Twist *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Twist, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Twist, sipName_ReverseSign, doc_Twist_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_Twist_RefPoint, "RefPoint(self, v_base_AB: Vector) -> Twist");

extern "C" {static PyObject *meth_Twist_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Twist_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Twist *sipCpp;

        static const char *sipKwdList[] = {
            sipName_v_base_AB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Twist, &sipCpp, sipType_Vector, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Twist, sipName_RefPoint, doc_Twist_RefPoint);

    return NULL;
}


extern "C" {static PyObject *slot_Twist___neg__(PyObject *);}
static PyObject *slot_Twist___neg__(PyObject *sipSelf)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;


    {
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_Twist___mul__(PyObject *,PyObject *);}
static PyObject *slot_Twist___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Twist, &a0, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        double a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_Twist, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Twist___div__(PyObject *,PyObject *);}
static PyObject *slot_Twist___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Twist, &a0, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Twist___add__(PyObject *,PyObject *);}
static PyObject *slot_Twist___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Twist, &a0, sipType_Twist, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Twist___sub__(PyObject *,PyObject *);}
static PyObject *slot_Twist___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Twist, &a0, sipType_Twist, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Twist___eq__(PyObject *,PyObject *);}
static PyObject *slot_Twist___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Twist, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_Twist, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Twist___ne__(PyObject *,PyObject *);}
static PyObject *slot_Twist___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Twist, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_Twist, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Twist___repr__(PyObject *);}
static PyObject *slot_Twist___repr__(PyObject *sipSelf)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 316 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    std::ostringstream oss;
    oss<<(*sipCpp);
    std::string s(oss.str());
    sipRes=&s;
#line 16349 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Twist___setitem__(PyObject *,PyObject *);}
static int slot_Twist___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 307 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 5) {
        PyErr_SetString(PyExc_IndexError, "Twist index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 16381 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Twist, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Twist___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Twist___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 298 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 5) {
        PyErr_SetString(PyExc_IndexError, "Twist index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 16417 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Twist, sipName___getitem__, NULL);

    return 0;
}


extern "C" {static PyObject *slot_Twist___iadd__(PyObject *,PyObject *);}
static PyObject *slot_Twist___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Twist)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Twist, &a0))
        {
            sipCpp-> ::Twist::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_Twist___isub__(PyObject *,PyObject *);}
static PyObject *slot_Twist___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Twist)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Twist));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Twist, &a0))
        {
            sipCpp-> ::Twist::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_Twist(void *, int);}
static void release_Twist(void *sipCppV, int)
{
    delete reinterpret_cast< ::Twist *>(sipCppV);
}


extern "C" {static PyObject *pickle_Twist(void *);}
static PyObject *pickle_Twist(void *sipCppV)
{
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipCppV);
    PyObject *sipRes;

#line 328 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    const sipTypeDef *vector_type = sipFindType("Vector");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->vel), vector_type, Py_None),
                                 sipConvertFromType(&(sipCpp->rot), vector_type, Py_None));
#line 16528 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_Twist(void *, SIP_SSIZE_T, void *);}
static void assign_Twist(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Twist *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Twist *>(sipSrc);
}


extern "C" {static void *array_Twist(SIP_SSIZE_T);}
static void *array_Twist(SIP_SSIZE_T sipNrElem)
{
    return new  ::Twist[sipNrElem];
}


extern "C" {static void *copy_Twist(const void *, SIP_SSIZE_T);}
static void *copy_Twist(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Twist(reinterpret_cast<const  ::Twist *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Twist(sipSimpleWrapper *);}
static void dealloc_Twist(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Twist(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Twist(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Twist(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Twist *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Twist();

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName__vel,
            sipName__rot,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::Twist(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Twist* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Twist, &a0))
        {
            sipCpp = new  ::Twist(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Twist[] = {
    {(void *)slot_Twist___neg__, neg_slot},
    {(void *)slot_Twist___mul__, mul_slot},
    {(void *)slot_Twist___div__, div_slot},
    {(void *)slot_Twist___add__, add_slot},
    {(void *)slot_Twist___sub__, sub_slot},
    {(void *)slot_Twist___eq__, eq_slot},
    {(void *)slot_Twist___ne__, ne_slot},
    {(void *)slot_Twist___repr__, repr_slot},
    {(void *)slot_Twist___setitem__, setitem_slot},
    {(void *)slot_Twist___getitem__, getitem_slot},
    {(void *)slot_Twist___iadd__, iadd_slot},
    {(void *)slot_Twist___isub__, isub_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Twist[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_Twist_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Twist_RefPoint)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_Twist_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_Twist_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_Twist_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_Twist_Zero)}
};


extern "C" {static PyObject *varget_Twist_rot(void *, PyObject *, PyObject *);}
static PyObject *varget_Twist_rot(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipSelf);

    sipVal = &sipCpp->rot;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_Twist_rot(void *, PyObject *, PyObject *);}
static int varset_Twist_rot(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->rot = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_Twist_vel(void *, PyObject *, PyObject *);}
static PyObject *varget_Twist_vel(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipSelf);

    sipVal = &sipCpp->vel;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_Twist_vel(void *, PyObject *, PyObject *);}
static int varset_Twist_vel(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::Twist *sipCpp = reinterpret_cast< ::Twist *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->vel = *sipVal;

    return 0;
}

sipVariableDef variables_Twist[] = {
    {InstanceVariable, sipName_rot, (PyMethodDef *)varget_Twist_rot, (PyMethodDef *)varset_Twist_rot, NULL, NULL},
    {InstanceVariable, sipName_vel, (PyMethodDef *)varget_Twist_vel, (PyMethodDef *)varset_Twist_vel, NULL, NULL},
};

PyDoc_STRVAR(doc_Twist, "\1Twist()\n"
"Twist(_vel: Vector, _rot: Vector)\n"
"Twist(Twist)");


sipClassTypeDef sipTypeDef_PyKDL_Twist = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Twist,
        {0},
        0
    },
    {
        sipNameNr_Twist,
        {0, 0, 1},
        3, methods_Twist,
        0, 0,
        2, variables_Twist,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Twist,
    -1,
    -1,
    0,
    slots_Twist,
    init_type_Twist,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Twist,
    assign_Twist,
    array_Twist,
    copy_Twist,
    release_Twist,
    0,
    0,
    0,
    0,
    pickle_Twist,
    0,
    0
};

#line 201 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16764 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 102 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16771 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16777 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16783 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 16789 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 186 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 16794 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 159 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 16798 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 16801 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Frame_DH_Craig1989, "DH_Craig1989(self, a: float, alpha: float, d: float, theta: float) -> Frame");

extern "C" {static PyObject *meth_Frame_DH_Craig1989(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Frame_DH_Craig1989(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        double a3;
         ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_alpha,
            sipName_d,
            sipName_theta,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdddd", &sipSelf, sipType_Frame, &sipCpp, &a0, &a1, &a2, &a3))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->DH_Craig1989(a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName_DH_Craig1989, doc_Frame_DH_Craig1989);

    return NULL;
}


PyDoc_STRVAR(doc_Frame_DH, "DH(self, a: float, alpha: float, d: float, theta: float) -> Frame");

extern "C" {static PyObject *meth_Frame_DH(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Frame_DH(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        double a3;
         ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_alpha,
            sipName_d,
            sipName_theta,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdddd", &sipSelf, sipType_Frame, &sipCpp, &a0, &a1, &a2, &a3))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->DH(a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName_DH, doc_Frame_DH);

    return NULL;
}


PyDoc_STRVAR(doc_Frame_Inverse, "Inverse(self) -> Frame\n"
"Inverse(self, arg: Vector) -> Vector\n"
"Inverse(self, arg: Wrench) -> Wrench\n"
"Inverse(self, arg: Twist) -> Twist");

extern "C" {static PyObject *meth_Frame_Inverse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Frame_Inverse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::Frame *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Frame, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Frame, &sipCpp, sipType_Vector, &a0))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Frame, &sipCpp, sipType_Wrench, &a0))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Frame, &sipCpp, sipType_Twist, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName_Inverse, doc_Frame_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_Frame_Identity, "Identity() -> Frame");

extern "C" {static PyObject *meth_Frame_Identity(PyObject *, PyObject *);}
static PyObject *meth_Frame_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame( ::Frame::Identity());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName_Identity, doc_Frame_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_Frame_Integrate, "Integrate(self, t_this: Twist, frequency: float)");

extern "C" {static PyObject *meth_Frame_Integrate(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Frame_Integrate(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Twist* a0;
        double a1;
         ::Frame *sipCpp;

        static const char *sipKwdList[] = {
            sipName_t_this,
            sipName_frequency,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9d", &sipSelf, sipType_Frame, &sipCpp, sipType_Twist, &a0, &a1))
        {
            sipCpp->Integrate(*a0,a1);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName_Integrate, doc_Frame_Integrate);

    return NULL;
}


extern "C" {static PyObject *slot_Frame___eq__(PyObject *,PyObject *);}
static PyObject *slot_Frame___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Frame));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Frame* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Frame, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_Frame, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Frame___ne__(PyObject *,PyObject *);}
static PyObject *slot_Frame___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Frame));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Frame* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Frame, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_Frame, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Frame___mul__(PyObject *,PyObject *);}
static PyObject *slot_Frame___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::Frame* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
         ::Frame* a0;
        const  ::Wrench* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_Wrench, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
         ::Frame* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_Twist, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Frame* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_Frame, &a1))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::FrameVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Frame, &a0, sipType_FrameVel, &a1))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Frame___repr__(PyObject *);}
static PyObject *slot_Frame___repr__(PyObject *sipSelf)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Frame));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 243 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    std::ostringstream oss;
    oss<<(*sipCpp);
    std::string s(oss.str());
    sipRes=&s;
#line 17210 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Frame___setitem__(PyObject *,PyObject *);}
static int slot_Frame___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Frame));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "Td", &PyTuple_Type, &a0, &a1))
        {
#line 229 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > 2 || j > 3) {
        PyErr_SetString(PyExc_IndexError, "Frame index out of range");
        return 0;
    }
    if(j==3)
        (*sipCpp).p(i)=a1;
    else
        (*sipCpp).M(i,j)=a1;
#line 17247 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Frame___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Frame___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Frame));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 218 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > 2 || j > 3) {
        PyErr_SetString(PyExc_IndexError, "Frame index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(i,j);
#line 17285 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Frame, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Frame(void *, int);}
static void release_Frame(void *sipCppV, int)
{
    delete reinterpret_cast< ::Frame *>(sipCppV);
}


extern "C" {static PyObject *pickle_Frame(void *);}
static PyObject *pickle_Frame(void *sipCppV)
{
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipCppV);
    PyObject *sipRes;

#line 265 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    const sipTypeDef *vector_type = sipFindType("Vector");
    const sipTypeDef *rotation_type = sipFindType("Rotation");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->M), rotation_type, Py_None),
                                 sipConvertFromType(&(sipCpp->p), vector_type, Py_None));
#line 17317 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_Frame(void *, SIP_SSIZE_T, void *);}
static void assign_Frame(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Frame *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Frame *>(sipSrc);
}


extern "C" {static void *array_Frame(SIP_SSIZE_T);}
static void *array_Frame(SIP_SSIZE_T sipNrElem)
{
    return new  ::Frame[sipNrElem];
}


extern "C" {static void *copy_Frame(const void *, SIP_SSIZE_T);}
static void *copy_Frame(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Frame(reinterpret_cast<const  ::Frame *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Frame(sipSimpleWrapper *);}
static void dealloc_Frame(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Frame(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Frame(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Frame(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Frame *sipCpp = 0;

    {
        const  ::Rotation* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_R,
            sipName_V,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Rotation, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::Frame(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;

        static const char *sipKwdList[] = {
            sipName_V,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Vector, &a0))
        {
            sipCpp = new  ::Frame(*a0);

            return sipCpp;
        }
    }

    {
        const  ::Rotation* a0;

        static const char *sipKwdList[] = {
            sipName_R,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Rotation, &a0))
        {
            sipCpp = new  ::Frame(*a0);

            return sipCpp;
        }
    }

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Frame();

            return sipCpp;
        }
    }

    {
        const  ::Frame* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Frame, &a0))
        {
            sipCpp = new  ::Frame(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Frame[] = {
    {(void *)slot_Frame___eq__, eq_slot},
    {(void *)slot_Frame___ne__, ne_slot},
    {(void *)slot_Frame___mul__, mul_slot},
    {(void *)slot_Frame___repr__, repr_slot},
    {(void *)slot_Frame___setitem__, setitem_slot},
    {(void *)slot_Frame___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Frame[] = {
    {SIP_MLNAME_CAST(sipName_DH), (PyCFunction)meth_Frame_DH, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Frame_DH)},
    {SIP_MLNAME_CAST(sipName_DH_Craig1989), (PyCFunction)meth_Frame_DH_Craig1989, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Frame_DH_Craig1989)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_Frame_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_Frame_Identity)},
    {SIP_MLNAME_CAST(sipName_Integrate), (PyCFunction)meth_Frame_Integrate, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Frame_Integrate)},
    {SIP_MLNAME_CAST(sipName_Inverse), (PyCFunction)meth_Frame_Inverse, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Frame_Inverse)}
};


extern "C" {static PyObject *varget_Frame_M(void *, PyObject *, PyObject *);}
static PyObject *varget_Frame_M(void *sipSelf, PyObject *, PyObject *)
{
     ::Rotation*sipVal;
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipSelf);

    sipVal = &sipCpp->M;

    return sipConvertFromType(sipVal, sipType_Rotation, NULL);
}


extern "C" {static int varset_Frame_M(void *, PyObject *, PyObject *);}
static int varset_Frame_M(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Rotation*sipVal;
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Rotation *>(sipForceConvertToType(sipPy,sipType_Rotation,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->M = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_Frame_p(void *, PyObject *, PyObject *);}
static PyObject *varget_Frame_p(void *sipSelf, PyObject *, PyObject *)
{
     ::Vector*sipVal;
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipSelf);

    sipVal = &sipCpp->p;

    return sipConvertFromType(sipVal, sipType_Vector, NULL);
}


extern "C" {static int varset_Frame_p(void *, PyObject *, PyObject *);}
static int varset_Frame_p(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::Vector*sipVal;
     ::Frame *sipCpp = reinterpret_cast< ::Frame *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::Vector *>(sipForceConvertToType(sipPy,sipType_Vector,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->p = *sipVal;

    return 0;
}

sipVariableDef variables_Frame[] = {
    {InstanceVariable, sipName_M, (PyMethodDef *)varget_Frame_M, (PyMethodDef *)varset_Frame_M, NULL, NULL},
    {InstanceVariable, sipName_p, (PyMethodDef *)varget_Frame_p, (PyMethodDef *)varset_Frame_p, NULL, NULL},
};

PyDoc_STRVAR(doc_Frame, "\1Frame(R: Rotation, V: Vector)\n"
"Frame(V: Vector)\n"
"Frame(R: Rotation)\n"
"Frame()\n"
"Frame(Frame)");


sipClassTypeDef sipTypeDef_PyKDL_Frame = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Frame,
        {0},
        0
    },
    {
        sipNameNr_Frame,
        {0, 0, 1},
        5, methods_Frame,
        0, 0,
        2, variables_Frame,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Frame,
    -1,
    -1,
    0,
    slots_Frame,
    init_type_Frame,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Frame,
    assign_Frame,
    array_Frame,
    copy_Frame,
    release_Frame,
    0,
    0,
    0,
    0,
    pickle_Frame,
    0,
    0
};

#line 102 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 17583 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 17590 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 281 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 17596 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 352 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 17602 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 186 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 17607 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 17611 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 100 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 17615 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 17618 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Rotation_SetInverse, "SetInverse(self)");

extern "C" {static PyObject *meth_Rotation_SetInverse(PyObject *, PyObject *);}
static PyObject *meth_Rotation_SetInverse(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::Rotation *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
            sipCpp->SetInverse();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_SetInverse, doc_Rotation_SetInverse);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_Inverse, "Inverse(self) -> Rotation\n"
"Inverse(self, v: Vector) -> Vector\n"
"Inverse(self, w: Wrench) -> Wrench\n"
"Inverse(self, t: Twist) -> Twist");

extern "C" {static PyObject *meth_Rotation_Inverse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_Inverse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Vector, &a0))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Wrench, &a0))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_t,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Twist, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_Inverse, doc_Rotation_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_Identity, "Identity() -> Rotation");

extern "C" {static PyObject *meth_Rotation_Identity(PyObject *, PyObject *);}
static PyObject *meth_Rotation_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::Identity());

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_Identity, doc_Rotation_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_RotX, "RotX(angle: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_RotX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_RotX(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "d", &a0))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::RotX(a0));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_RotX, doc_Rotation_RotX);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_RotY, "RotY(angle: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_RotY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_RotY(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "d", &a0))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::RotY(a0));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_RotY, doc_Rotation_RotY);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_RotZ, "RotZ(angle: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_RotZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_RotZ(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "d", &a0))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::RotZ(a0));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_RotZ, doc_Rotation_RotZ);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_Rot, "Rot(vec: Vector, angle: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_Rot(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_Rot(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        double a1;

        static const char *sipKwdList[] = {
            sipName_vec,
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9d", sipType_Vector, &a0, &a1))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::Rot(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_Rot, doc_Rotation_Rot);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_Rot2, "Rot2(vec: Vector, angle: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_Rot2(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_Rot2(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        double a1;

        static const char *sipKwdList[] = {
            sipName_vec,
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9d", sipType_Vector, &a0, &a1))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::Rot2(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_Rot2, doc_Rotation_Rot2);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_EulerZYZ, "EulerZYZ(Alfa: float, Beta: float, Gamma: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_EulerZYZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_EulerZYZ(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_Alfa,
            sipName_Beta,
            sipName_Gamma,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "ddd", &a0, &a1, &a2))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::EulerZYZ(a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_EulerZYZ, doc_Rotation_EulerZYZ);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_RPY, "RPY(roll: float, pitch: float, yaw: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_RPY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_RPY(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_roll,
            sipName_pitch,
            sipName_yaw,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "ddd", &a0, &a1, &a2))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::RPY(a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_RPY, doc_Rotation_RPY);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_EulerZYX, "EulerZYX(Alfa: float, Beta: float, Gamma: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_EulerZYX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_EulerZYX(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_Alfa,
            sipName_Beta,
            sipName_Gamma,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "ddd", &a0, &a1, &a2))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::EulerZYX(a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_EulerZYX, doc_Rotation_EulerZYX);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_Quaternion, "Quaternion(x: float, y: float, z: float, w: float) -> Rotation");

extern "C" {static PyObject *meth_Rotation_Quaternion(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_Quaternion(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        double a3;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_z,
            sipName_w,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "dddd", &a0, &a1, &a2, &a3))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation( ::Rotation::Quaternion(a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_Quaternion, doc_Rotation_Quaternion);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_DoRotX, "DoRotX(self, angle: float)");

extern "C" {static PyObject *meth_Rotation_DoRotX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_DoRotX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Rotation, &sipCpp, &a0))
        {
            sipCpp->DoRotX(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_DoRotX, doc_Rotation_DoRotX);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_DoRotY, "DoRotY(self, angle: float)");

extern "C" {static PyObject *meth_Rotation_DoRotY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_DoRotY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Rotation, &sipCpp, &a0))
        {
            sipCpp->DoRotY(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_DoRotY, doc_Rotation_DoRotY);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_DoRotZ, "DoRotZ(self, angle: float)");

extern "C" {static PyObject *meth_Rotation_DoRotZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_DoRotZ(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Rotation, &sipCpp, &a0))
        {
            sipCpp->DoRotZ(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_DoRotZ, doc_Rotation_DoRotZ);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetRot, "GetRot(self) -> Vector");

extern "C" {static PyObject *meth_Rotation_GetRot(PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetRot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->GetRot());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetRot, doc_Rotation_GetRot);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetRotAngle, "GetRotAngle(self, eps: float = epsilon) -> Tuple[float, Vector]");

extern "C" {static PyObject *meth_Rotation_GetRotAngle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetRotAngle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::Vector* a0;
        double a1 = epsilon;
        const  ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|d", &sipSelf, sipType_Rotation, &sipCpp, &a1))
        {
            double sipRes;
            a0 = new  ::Vector();

            sipRes = sipCpp->GetRotAngle(*a0,a1);

            return sipBuildResult(0,"(dN)",sipRes,a0,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetRotAngle, doc_Rotation_GetRotAngle);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetEulerZYZ, "GetEulerZYZ(self) -> Tuple[float, float, float]");

extern "C" {static PyObject *meth_Rotation_GetEulerZYZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetEulerZYZ(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
            sipCpp->GetEulerZYZ(a0,a1,a2);

            return sipBuildResult(0,"(ddd)",a0,a1,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetEulerZYZ, doc_Rotation_GetEulerZYZ);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetRPY, "GetRPY(self) -> Tuple[float, float, float]");

extern "C" {static PyObject *meth_Rotation_GetRPY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetRPY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
            sipCpp->GetRPY(a0,a1,a2);

            return sipBuildResult(0,"(ddd)",a0,a1,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetRPY, doc_Rotation_GetRPY);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetEulerZYX, "GetEulerZYX(self) -> Tuple[float, float, float]");

extern "C" {static PyObject *meth_Rotation_GetEulerZYX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetEulerZYX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
            sipCpp->GetEulerZYX(a0,a1,a2);

            return sipBuildResult(0,"(ddd)",a0,a1,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetEulerZYX, doc_Rotation_GetEulerZYX);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_GetQuaternion, "GetQuaternion(self) -> Tuple[float, float, float, float]");

extern "C" {static PyObject *meth_Rotation_GetQuaternion(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_GetQuaternion(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        double a3;
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
            sipCpp->GetQuaternion(a0,a1,a2,a3);

            return sipBuildResult(0,"(dddd)",a0,a1,a2,a3);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_GetQuaternion, doc_Rotation_GetQuaternion);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_UnitX, "UnitX(self) -> Vector\n"
"UnitX(self, X: Vector)");

extern "C" {static PyObject *meth_Rotation_UnitX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_UnitX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->UnitX());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_X,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Vector, &a0))
        {
            sipCpp->UnitX(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_UnitX, doc_Rotation_UnitX);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_UnitY, "UnitY(self) -> Vector\n"
"UnitY(self, X: Vector)");

extern "C" {static PyObject *meth_Rotation_UnitY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_UnitY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->UnitY());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_X,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Vector, &a0))
        {
            sipCpp->UnitY(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_UnitY, doc_Rotation_UnitY);

    return NULL;
}


PyDoc_STRVAR(doc_Rotation_UnitZ, "UnitZ(self) -> Vector\n"
"UnitZ(self, X: Vector)");

extern "C" {static PyObject *meth_Rotation_UnitZ(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Rotation_UnitZ(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_Rotation, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->UnitZ());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
         ::Rotation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_X,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Rotation, &sipCpp, sipType_Vector, &a0))
        {
            sipCpp->UnitZ(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName_UnitZ, doc_Rotation_UnitZ);

    return NULL;
}


extern "C" {static PyObject *slot_Rotation___eq__(PyObject *,PyObject *);}
static PyObject *slot_Rotation___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Rotation));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Rotation, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_Rotation, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Rotation___ne__(PyObject *,PyObject *);}
static PyObject *slot_Rotation___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Rotation));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Rotation* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Rotation, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_Rotation, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Rotation___mul__(PyObject *,PyObject *);}
static PyObject *slot_Rotation___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::Rotation* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
         ::Rotation* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_Twist, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
         ::Rotation* a0;
        const  ::Wrench* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_Wrench, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Rotation* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_Rotation, &a1))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::RotationVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Rotation, &a0, sipType_RotationVel, &a1))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Rotation___repr__(PyObject *);}
static PyObject *slot_Rotation___repr__(PyObject *sipSelf)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Rotation));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 139 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    std::ostringstream oss;
    oss<<(*sipCpp);
    std::string s(oss.str());
    sipRes=&s;
#line 18683 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Rotation___setitem__(PyObject *,PyObject *);}
static int slot_Rotation___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Rotation));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "Td", &PyTuple_Type, &a0, &a1))
        {
#line 128 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > 2 || j > 2) {
        PyErr_SetString(PyExc_IndexError, "Rotation index out of range");
        return 0;
    }
    (*sipCpp)(i,j)=a1;
#line 18717 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Rotation___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Rotation___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Rotation));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 117 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    int i,j;
    PyArg_ParseTuple(a0, "ii", &i, &j);
    if (i < 0 || j < 0 || i > 2 || j > 2) {
        PyErr_SetString(PyExc_IndexError, "Rotation index out of range");
        return 0;
    }
    sipRes=((const Rotation)(*sipCpp))(i,j);
#line 18755 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Rotation, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Rotation(void *, int);}
static void release_Rotation(void *sipCppV, int)
{
    delete reinterpret_cast< ::Rotation *>(sipCppV);
}


extern "C" {static PyObject *pickle_Rotation(void *);}
static PyObject *pickle_Rotation(void *sipCppV)
{
     ::Rotation *sipCpp = reinterpret_cast< ::Rotation *>(sipCppV);
    PyObject *sipRes;

#line 188 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    sipRes = Py_BuildValue("ddddddddd", (*sipCpp)(0,0), (*sipCpp)(0,1), (*sipCpp)(0,2),
                                        (*sipCpp)(1,0), (*sipCpp)(1,1), (*sipCpp)(1,2),
                                        (*sipCpp)(2,0), (*sipCpp)(2,1), (*sipCpp)(2,2));
#line 18786 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_Rotation(void *, SIP_SSIZE_T, void *);}
static void assign_Rotation(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Rotation *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Rotation *>(sipSrc);
}


extern "C" {static void *array_Rotation(SIP_SSIZE_T);}
static void *array_Rotation(SIP_SSIZE_T sipNrElem)
{
    return new  ::Rotation[sipNrElem];
}


extern "C" {static void *copy_Rotation(const void *, SIP_SSIZE_T);}
static void *copy_Rotation(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Rotation(reinterpret_cast<const  ::Rotation *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Rotation(sipSimpleWrapper *);}
static void dealloc_Rotation(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Rotation(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Rotation(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Rotation(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Rotation *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Rotation();

            return sipCpp;
        }
    }

    {
        double a0;
        double a1;
        double a2;
        double a3;
        double a4;
        double a5;
        double a6;
        double a7;
        double a8;

        static const char *sipKwdList[] = {
            sipName_Xx,
            sipName_Yx,
            sipName_Zx,
            sipName_Xy,
            sipName_Yy,
            sipName_Zy,
            sipName_Xz,
            sipName_Yz,
            sipName_Zz,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "ddddddddd", &a0, &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8))
        {
            sipCpp = new  ::Rotation(a0,a1,a2,a3,a4,a5,a6,a7,a8);

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        const  ::Vector* a2;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_z,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9", sipType_Vector, &a0, sipType_Vector, &a1, sipType_Vector, &a2))
        {
            sipCpp = new  ::Rotation(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::Rotation* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Rotation, &a0))
        {
            sipCpp = new  ::Rotation(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Rotation[] = {
    {(void *)slot_Rotation___eq__, eq_slot},
    {(void *)slot_Rotation___ne__, ne_slot},
    {(void *)slot_Rotation___mul__, mul_slot},
    {(void *)slot_Rotation___repr__, repr_slot},
    {(void *)slot_Rotation___setitem__, setitem_slot},
    {(void *)slot_Rotation___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Rotation[] = {
    {SIP_MLNAME_CAST(sipName_DoRotX), (PyCFunction)meth_Rotation_DoRotX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_DoRotX)},
    {SIP_MLNAME_CAST(sipName_DoRotY), (PyCFunction)meth_Rotation_DoRotY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_DoRotY)},
    {SIP_MLNAME_CAST(sipName_DoRotZ), (PyCFunction)meth_Rotation_DoRotZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_DoRotZ)},
    {SIP_MLNAME_CAST(sipName_EulerZYX), (PyCFunction)meth_Rotation_EulerZYX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_EulerZYX)},
    {SIP_MLNAME_CAST(sipName_EulerZYZ), (PyCFunction)meth_Rotation_EulerZYZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_EulerZYZ)},
    {SIP_MLNAME_CAST(sipName_GetEulerZYX), (PyCFunction)meth_Rotation_GetEulerZYX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_GetEulerZYX)},
    {SIP_MLNAME_CAST(sipName_GetEulerZYZ), (PyCFunction)meth_Rotation_GetEulerZYZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_GetEulerZYZ)},
    {SIP_MLNAME_CAST(sipName_GetQuaternion), (PyCFunction)meth_Rotation_GetQuaternion, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_GetQuaternion)},
    {SIP_MLNAME_CAST(sipName_GetRPY), (PyCFunction)meth_Rotation_GetRPY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_GetRPY)},
    {SIP_MLNAME_CAST(sipName_GetRot), meth_Rotation_GetRot, METH_VARARGS, SIP_MLDOC_CAST(doc_Rotation_GetRot)},
    {SIP_MLNAME_CAST(sipName_GetRotAngle), (PyCFunction)meth_Rotation_GetRotAngle, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_GetRotAngle)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_Rotation_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_Rotation_Identity)},
    {SIP_MLNAME_CAST(sipName_Inverse), (PyCFunction)meth_Rotation_Inverse, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_Inverse)},
    {SIP_MLNAME_CAST(sipName_Quaternion), (PyCFunction)meth_Rotation_Quaternion, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_Quaternion)},
    {SIP_MLNAME_CAST(sipName_RPY), (PyCFunction)meth_Rotation_RPY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_RPY)},
    {SIP_MLNAME_CAST(sipName_Rot), (PyCFunction)meth_Rotation_Rot, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_Rot)},
    {SIP_MLNAME_CAST(sipName_Rot2), (PyCFunction)meth_Rotation_Rot2, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_Rot2)},
    {SIP_MLNAME_CAST(sipName_RotX), (PyCFunction)meth_Rotation_RotX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_RotX)},
    {SIP_MLNAME_CAST(sipName_RotY), (PyCFunction)meth_Rotation_RotY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_RotY)},
    {SIP_MLNAME_CAST(sipName_RotZ), (PyCFunction)meth_Rotation_RotZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_RotZ)},
    {SIP_MLNAME_CAST(sipName_SetInverse), meth_Rotation_SetInverse, METH_VARARGS, SIP_MLDOC_CAST(doc_Rotation_SetInverse)},
    {SIP_MLNAME_CAST(sipName_UnitX), (PyCFunction)meth_Rotation_UnitX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_UnitX)},
    {SIP_MLNAME_CAST(sipName_UnitY), (PyCFunction)meth_Rotation_UnitY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_UnitY)},
    {SIP_MLNAME_CAST(sipName_UnitZ), (PyCFunction)meth_Rotation_UnitZ, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Rotation_UnitZ)}
};

PyDoc_STRVAR(doc_Rotation, "\1Rotation()\n"
"Rotation(Xx: float, Yx: float, Zx: float, Xy: float, Yy: float, Zy: float, Xz: float, Yz: float, Zz: float)\n"
"Rotation(x: Vector, y: Vector, z: Vector)\n"
"Rotation(Rotation)");


sipClassTypeDef sipTypeDef_PyKDL_Rotation = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Rotation,
        {0},
        0
    },
    {
        sipNameNr_Rotation,
        {0, 0, 1},
        24, methods_Rotation,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Rotation,
    -1,
    -1,
    0,
    slots_Rotation,
    init_type_Rotation,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Rotation,
    assign_Rotation,
    array_Rotation,
    copy_Rotation,
    release_Rotation,
    0,
    0,
    0,
    0,
    pickle_Rotation,
    0,
    0
};

#line 26 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 19005 "sip_PyKDL/sipPyKDLpart0.cpp"

#line 44 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 19010 "sip_PyKDL/sipPyKDLpart0.cpp"
#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 19013 "sip_PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_Vector_x, "x(self, float)\n"
"x(self) -> float");

extern "C" {static PyObject *meth_Vector_x(PyObject *, PyObject *);}
static PyObject *meth_Vector_x(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_Vector, &sipCpp, &a0))
        {
            sipCpp->x(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Vector, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->x();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_x, doc_Vector_x);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_y, "y(self, float)\n"
"y(self) -> float");

extern "C" {static PyObject *meth_Vector_y(PyObject *, PyObject *);}
static PyObject *meth_Vector_y(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_Vector, &sipCpp, &a0))
        {
            sipCpp->y(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Vector, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->y();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_y, doc_Vector_y);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_z, "z(self, float)\n"
"z(self) -> float");

extern "C" {static PyObject *meth_Vector_z(PyObject *, PyObject *);}
static PyObject *meth_Vector_z(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_Vector, &sipCpp, &a0))
        {
            sipCpp->z(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Vector, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->z();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_z, doc_Vector_z);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_Vector_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_Vector_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Vector, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_ReverseSign, doc_Vector_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_Zero, "Zero() -> Vector");

extern "C" {static PyObject *meth_Vector_Zero(PyObject *, PyObject *);}
static PyObject *meth_Vector_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector( ::Vector::Zero());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_Zero, doc_Vector_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_Norm, "Norm(self) -> float");

extern "C" {static PyObject *meth_Vector_Norm(PyObject *, PyObject *);}
static PyObject *meth_Vector_Norm(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::Vector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Vector, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->Norm();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_Norm, doc_Vector_Norm);

    return NULL;
}


PyDoc_STRVAR(doc_Vector_Normalize, "Normalize(self, eps: float = epsilon) -> float");

extern "C" {static PyObject *meth_Vector_Normalize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Vector_Normalize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0 = epsilon;
         ::Vector *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|d", &sipSelf, sipType_Vector, &sipCpp, &a0))
        {
            double sipRes;

            sipRes = sipCpp->Normalize(a0);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName_Normalize, doc_Vector_Normalize);

    return NULL;
}


extern "C" {static PyObject *slot_Vector___neg__(PyObject *);}
static PyObject *slot_Vector___neg__(PyObject *sipSelf)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;


    {
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_Vector___mul__(PyObject *,PyObject *);}
static PyObject *slot_Vector___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Vector, &a0, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        double a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Vector___div__(PyObject *,PyObject *);}
static PyObject *slot_Vector___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_Vector, &a0, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Vector___add__(PyObject *,PyObject *);}
static PyObject *slot_Vector___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Vector___sub__(PyObject *,PyObject *);}
static PyObject *slot_Vector___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_Vector___eq__(PyObject *,PyObject *);}
static PyObject *slot_Vector___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Vector, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_Vector, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Vector___ne__(PyObject *,PyObject *);}
static PyObject *slot_Vector___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Vector, &a0))
        {
            bool sipRes;

            sipRes = operator!=((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_Vector, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_Vector___iadd__(PyObject *,PyObject *);}
static PyObject *slot_Vector___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Vector)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Vector, &a0))
        {
            sipCpp-> ::Vector::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_Vector___isub__(PyObject *,PyObject *);}
static PyObject *slot_Vector___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_Vector)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_Vector, &a0))
        {
            sipCpp-> ::Vector::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_Vector___repr__(PyObject *);}
static PyObject *slot_Vector___repr__(PyObject *sipSelf)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 65 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    std::ostringstream oss;
    oss<<(*sipCpp);
    std::string s(oss.str());
    sipRes=&s;
#line 19626 "sip_PyKDL/sipPyKDLpart0.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_Vector___setitem__(PyObject *,PyObject *);}
static int slot_Vector___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 56 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 2) {
        PyErr_SetString(PyExc_IndexError, "Vector index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 19658 "sip_PyKDL/sipPyKDLpart0.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_Vector___getitem__(PyObject *,PyObject *);}
static PyObject *slot_Vector___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Vector));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 47 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    if (a0 < 0 || a0 > 2) {
	    PyErr_SetString(PyExc_IndexError, "Vector index out of range");
	    return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 19694 "sip_PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Vector, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Vector(void *, int);}
static void release_Vector(void *sipCppV, int)
{
    delete reinterpret_cast< ::Vector *>(sipCppV);
}


extern "C" {static PyObject *pickle_Vector(void *);}
static PyObject *pickle_Vector(void *sipCppV)
{
     ::Vector *sipCpp = reinterpret_cast< ::Vector *>(sipCppV);
    PyObject *sipRes;

#line 82 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
    sipRes = Py_BuildValue("ddd", sipCpp->x(), sipCpp->y(), sipCpp->z());
#line 19723 "sip_PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_Vector(void *, SIP_SSIZE_T, void *);}
static void assign_Vector(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Vector *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Vector *>(sipSrc);
}


extern "C" {static void *array_Vector(SIP_SSIZE_T);}
static void *array_Vector(SIP_SSIZE_T sipNrElem)
{
    return new  ::Vector[sipNrElem];
}


extern "C" {static void *copy_Vector(const void *, SIP_SSIZE_T);}
static void *copy_Vector(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Vector(reinterpret_cast<const  ::Vector *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Vector(sipSimpleWrapper *);}
static void dealloc_Vector(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Vector(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Vector(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Vector(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Vector *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Vector();

            return sipCpp;
        }
    }

    {
        double a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_z,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "ddd", &a0, &a1, &a2))
        {
            sipCpp = new  ::Vector(a0,a1,a2);

            return sipCpp;
        }
    }

    {
        const  ::Vector* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Vector, &a0))
        {
            sipCpp = new  ::Vector(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Vector[] = {
    {(void *)slot_Vector___neg__, neg_slot},
    {(void *)slot_Vector___mul__, mul_slot},
    {(void *)slot_Vector___div__, div_slot},
    {(void *)slot_Vector___add__, add_slot},
    {(void *)slot_Vector___sub__, sub_slot},
    {(void *)slot_Vector___eq__, eq_slot},
    {(void *)slot_Vector___ne__, ne_slot},
    {(void *)slot_Vector___iadd__, iadd_slot},
    {(void *)slot_Vector___isub__, isub_slot},
    {(void *)slot_Vector___repr__, repr_slot},
    {(void *)slot_Vector___setitem__, setitem_slot},
    {(void *)slot_Vector___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Vector[] = {
    {SIP_MLNAME_CAST(sipName_Norm), meth_Vector_Norm, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_Norm)},
    {SIP_MLNAME_CAST(sipName_Normalize), (PyCFunction)meth_Vector_Normalize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Vector_Normalize)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_Vector_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_Vector_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_Zero)},
    {SIP_MLNAME_CAST(sipName_x), meth_Vector_x, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_x)},
    {SIP_MLNAME_CAST(sipName_y), meth_Vector_y, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_y)},
    {SIP_MLNAME_CAST(sipName_z), meth_Vector_z, METH_VARARGS, SIP_MLDOC_CAST(doc_Vector_z)}
};

PyDoc_STRVAR(doc_Vector, "\1Vector()\n"
"Vector(x: float, y: float, z: float)\n"
"Vector(arg: Vector)");


sipClassTypeDef sipTypeDef_PyKDL_Vector = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Vector,
        {0},
        0
    },
    {
        sipNameNr_Vector,
        {0, 0, 1},
        7, methods_Vector,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Vector,
    -1,
    -1,
    0,
    slots_Vector,
    init_type_Vector,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Vector,
    assign_Vector,
    array_Vector,
    copy_Vector,
    release_Vector,
    0,
    0,
    0,
    0,
    pickle_Vector,
    0,
    0
};

#line 21 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 19899 "sip_PyKDL/sipPyKDLpart0.cpp"



extern "C" {static void assign_std_string(void *, SIP_SSIZE_T, void *);}
static void assign_std_string(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::std::string *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::std::string *>(sipSrc);
}


extern "C" {static void *array_std_string(SIP_SSIZE_T);}
static void *array_std_string(SIP_SSIZE_T sipNrElem)
{
    return new  ::std::string[sipNrElem];
}


extern "C" {static void *copy_std_string(const void *, SIP_SSIZE_T);}
static void *copy_std_string(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::std::string(reinterpret_cast<const  ::std::string *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_std_string(void *, int);}
static void release_std_string(void *ptr, int)
{
    delete reinterpret_cast< ::std::string *>(ptr);
}



extern "C" {static int convertTo_std_string(PyObject *, void **, int *, PyObject *);}
static int convertTo_std_string(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *)
{
     ::std::string **sipCppPtr = reinterpret_cast< ::std::string **>(sipCppPtrV);

#line 36 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
     // Allow a Python string (or a unicode string) whenever a string is
     // expected.
    // If argument is a Unicode string, just decode it to UTF-8
    // If argument is a Python string, assume it's UTF-8
     if (sipIsErr == NULL)
#if PY_MAJOR_VERSION < 3
        return (PyString_Check(sipPy) || PyUnicode_Check(sipPy));
#else
        return PyUnicode_Check(sipPy);
#endif
     if (sipPy == Py_None) {
        *sipCppPtr = new std::string;
         return 1;
     }
#if PY_MAJOR_VERSION < 3
     if (PyUnicode_Check(sipPy)) {
        PyObject* s = PyUnicode_AsUTF8String(sipPy);
        *sipCppPtr = new std::string(PyString_AS_STRING(s));
        Py_DECREF(s);
        return 1;
     }
     else if (PyString_Check(sipPy)) {
        *sipCppPtr = new std::string(PyString_AS_STRING(sipPy));
        return 1;
     }
#else
     if (PyUnicode_Check(sipPy)) {
        *sipCppPtr = new std::string(PyUnicode_AsUTF8(sipPy));
        return 1;
     }
#endif

     return 0;
#line 19972 "sip_PyKDL/sipPyKDLpart0.cpp"
}


extern "C" {static PyObject *convertFrom_std_string(void *, PyObject *);}
static PyObject *convertFrom_std_string(void *sipCppV, PyObject *)
{
    ::std::string *sipCpp = reinterpret_cast< ::std::string *>(sipCppV);

#line 25 "orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
    // convert an std::string to a Python (unicode) string
    PyObject* newstring;
    newstring = PyUnicode_DecodeUTF8(sipCpp->c_str(), sipCpp->length(), NULL);
    if(newstring == NULL) {
        PyErr_Clear();
        newstring = PyUnicode_FromString(sipCpp->c_str());
    }
    return newstring;
#line 19990 "sip_PyKDL/sipPyKDLpart0.cpp"
}


sipMappedTypeDef sipTypeDef_PyKDL_std_string = {
    {
        -1,
        0,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_std__string,     /* std::string */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_std_string,
    array_std_string,
    copy_std_string,
    release_std_string,
    convertTo_std_string,
    convertFrom_std_string
};
